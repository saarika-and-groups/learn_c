<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C Language Roadmap</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <h2 id="main-title">C Programming Language Roadmap</h2>

  <div class="container" id="roadmap">
    <div class="box" onclick="showDetails('intro')">Introduction to C and its History</div>
    <div class="box" onclick="showDetails('env')">Setting up the C Development Environment</div>
    <div class="box" onclick="showDetails('input-output')">Basic input an output </div>
    <div class="box" onclick="showDetails('token-keywords')">token-keywords </div>
    <div class="box" onclick="showDetails('types')">Data Types</div>
    <div class="box" onclick="showDetails('control')">Control Flow</div>
    <div class="box" onclick="showDetails('functions')">Functions</div>
    <div class="box" onclick="showDetails('arrays')">Arrays</div>
    <div class="box" onclick="showDetails('pointers')">pointer</div>
    <div class="box" onclick="showDetails('memorymanagement')">Memory Management</div>
    <div class="box" onclick="showDetails('structunienum')">Stuctures, Unions and enums</div>
    <div class="box" onclick="showDetails('filehandling')">File Handling</div>
    <div class="box" onclick="showDetails('dynamic')">Dynamic Memory Allocation</div>
    <div class="box" onclick="showDetails('prepro')">Preproccessor Derectives And marcos</div>
    <div class="box" onclick="showDetails('error')">Error Handling and Debugging Techniques</div>
    <div class="box" onclick="showDetails('dsa')">DSA Using C</div>
  </div>

  <div class="details" id="intro">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Introduction to C </h3>
    <p>C is a general-purpose procedural programming language initially developed by Dennis Ritchie in 1972 at Bell
      Laboratories of AT&T Labs. It was mainly created as a system programming language to write the UNIX operating
      system.</p>
    <img src="Features-Of-C-language.webp" alt="" align="center">
    <p>Why Learn C?
      C is considered mother of all programming languages as many later languages have borrowed syntax/features directly
      or indirectly from the C language like the syntax of Java, PHP, JavaScript, and many other languages that are
      mainly based on the C language.

      So, if a person learns C programming first, it will help them to learn any modern programming language as well
      provide a deeper understanding of the fundamentals of programming and underlying architecture of the operating
      system like pointers, working with memory locations etc.</p>

  </div>
  <div class="details" id="intro">
    <button class="close-btn" onclick="hideAll()">× Close</button>

    <pre><h3>Hello World Program in C</h3>
      #include <stdio.h>
int main(void)
{
    // This prints "Hello World"
    printf("Hello World");
    return 0;  
}
    </pre>
    <output>
      Hello World
    </output>

  </div>
  <div class="details" id="intro">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Features of C</h3>
    <ul>
      <li>Simple and easy to learn</li>
      <li>Structured programming language</li>
      <li>Low-level access to memory</li>
      <li>Rich set of built-in operators</li>
      <li>Portability across platforms</li>
      <li>Extensive use in system programming</li>
      <li>Supports recursion and pointers</li>
  </div>
  <div class="details" id="intro">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Applications of C</h3>
    <ul>
      <li>Operating Systems (e.g., UNIX, Linux)</li>
      <li>Embedded Systems</li>
      <li>Compilers and Interpreters</li>
      <li>Database Management Systems</li>
      <li>Game Development</li>
      <li>Network Programming</li>
      <li>Scientific Computing</li>
    </ul>

  </div>
  <div class="details" id="intro">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Structure of C</h3>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250227185831242787/structure-of-c-program.webp"
      alt="Structure of C Program" align="center">

  </div>

  <div class="details" id="env">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Setting up the C Development Environment</h3>
    <pre>
1. Install a C Compiler:
    - For Windows: Use MinGW or TDM-GCC.
    - For macOS: Use Xcode Command Line Tools.
    - For Linux: GCC is usually pre-installed or can be installed via package manager.



2. Choose an IDE or Text Editor:
    - IDEs: Code::Blocks, Dev-C++, CLion, Visual Studio.
    - Text Editors: Visual Studio Code, Sublime Text, Atom, or even Notepad++.
      
    - For Visual Studio Code, install the C/C++ extension for better support.
      <a href="https://code.visualstudio.com/docs/languages/cpp"><h4> Visual Studio code</h4></a>

    -for online coding, you can use platforms like Replit, CodeChef IDE, or Paiza.IO.
      <a href="https://paiza.io/en/projects/new?language=c"><h4>Paiza.IO</h4></a>
      <a href="https://replit.com/languages/c"><h4>Replit</h4></a>
      <a href="https://www.codechef.com/ide"><h4>CodeChef IDE</h4></a>

3. Write Your First C Program:
    - Open your IDE or text editor.
    - Create a new file with a `.c` extension.
    - Write a simple C program, e.g.:
      ```c

      #include <stdio.h>
      int main() {
          printf("Hello, World!\n");
          return 0;
      }
      ```


4. Compile and Run:
    - If using an IDE, there will typically be a "Run" button.
    - If using a terminal, navigate to the directory where your file is saved and run:
      ```
      gcc -o hello hello.c
      ./hello
      ```
      

    </pre>
  </div>

  <div class="details" id="input-output">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Basic Input and Output</h3>
    <h4>
      basic output in C
    </h4>
    <p>
      In C, there are many functions used for output in different situations, but the most commonly used function for
      output is printf().

      The printf() function is used to print formatted output to the standard output stdout (which is generally the
      console screen). It is one of the most commonly used functions in C.
    </p>
    <h4>syntax of printf() function: printf("formatted_string", variables/values);</h4>
    <pre>
      #include <stdio.h>
      int main() {
          printf("Hello, World!\n");
          return 0;
      }
    </pre>
    <h4>Basic Input in C</h4>
    <p>
      These functions provide ways to read data from the user and use it in the programs . Among the most commonly used
      input functions are scanf() for reading formatted data and getchar() for reading a single character.

      scanf() is used to read user input from the console. It takes the format string and the addresses of the variables
      where the input will be stored.
    </p>
    <h4>syntax of scanf() function: scanf("format_string", &variable);</h4>
    <pre>
      #include <stdio.h>

int main() {
    int age;
    printf("Enter your age: ");
  
    // Reads an integer
    scanf("%d", &age);  
  
    // Prints the age
    printf("Age is: %d\n", age);  
    return 0;
}
    </pre>
  </div>
  <div class="details" id="token-keywords">
    <button class="close-btn" onclick="hideAll()">× Close</button>

    <h1>Token and Keywords</h1>
    <h1>Token</h1>
    <p>
      In C programming, tokens are the smallest units in a program that have meaningful representations. Tokens are the
      building blocks of a C program, and they are recognized by the C compiler to form valid expressions and
      statements. Tokens can be classified into various categories, each with specific roles in the program.
    </p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20241224114151560126/Tokens-in-C.webp" alt="token-img">
    <h1>Keywords</h1>
    <p>
      In C Programming language, there are many rules so to avoid different types of errors. One of such rule is not
      able to declare variable names with auto, long, etc. This is all because these are keywords. Let us check all
      keywords in C language.
    </p>
    <h3>Some keywords</h3>
    <ul>
      <li>auto</li>
      <li>break</li>
      <li>case</li>
      <li>char</li>
      <li>const</li>
      <li>continue</li>
      <li>default</li>
      <li>do</li>
      <li>double</li>
      <li>else</li>
      <li>enum</li>
      <li>extern</li>
      <li>float</li>
      <li>for</li>
      <li>goto</li>
      <li>if</li>
      <li>int</li>
      <li>long</li>
      <li>register</li>
      <li>return</li>
      <li>schar</li>
      <li>short</li>
      <li>sine</li>
      <li>sizeof</li>
      <li>static</li>
      <li>struct</li>
      <li>switch</li>
      <li>typedef</li>
      <li>union</li>
      <li>unsigned</li>
      <li>void</li>
    </ul>
    <h2>For further refrences</h2>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c-keywords/">GeeksforGeeks</a></li>
      <li><a href="https://www.programiz.com/c-programming/c-keywords">Programiz</a></li>
      <li><a href="https://www.javatpoint.com/c-keywords">JavaTpoint</a></li>
    </ul>
  </div>


  <div class="details" id="types">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Data Types</h3>
    <p>Defination : The data type specifies the size and type of information the variable will store.</p>
    <ul>
      <li>int</li>
      <li>float</li>
      <li>double</li>
      <li>char</li>
      <li>String</li>

    </ul>
    <h3>int</h3>
    <p>int is a data type that is used to store integer values. It can store both positive and negative whole numbers.
      The size of an int is typically 4 bytes (32 bits) on most systems.</p>
    <h3>float</h3>
    <p>float is a data type that is used to store single-precision floating-point
      numbers. It can store decimal values with a limited precision. The size of a float is typically 4 bytes (32
      bits).</p>
    <h3>double</h3>
    <p>double is a data type that is used to store double-precision floating-point
      numbers. It can store decimal values with higher precision than float. The size of a double is typically 8 bytes
      (64 bits).</p>
    <h3>char</h3>
    <p>char is a data type that is used to store single characters. It can store any character from the ASCII
      character set. The size of a char is typically 1 byte (8 bits).</p>
    <h3>Strings</h3>
    <p>string is collections of characters and sequnces and it should be enclosed by double ot single qoute ("",'') </p>
    <h3>Example</h3>
    <pre>

      #include <stdio.h>
          int main() {
              int age = 25; // Integer data type
              float height = 5.9; // Float data type
              double salary = 50000.50; // Double data type
              char grade = 'A'; // Character data type
              string name="saarika and Groups"; // string data type

              printf("Age: %d\n", age);
              printf("Height: %.1f\n", height);
              printf("Salary: %.2lf\n", salary);
              printf("Grade: %c\n", grade);
              printf("Name: %s\n", name);

              return 0;
          }
    </pre>
    <h3>Output</h3>
    <pre>
      Age: 25
      Height: 5.9
      Salary: 50000.50
      Grade: A
      Name:saarika and Groups
      </pre>

  </div>
  <div class="details" id="types">
    <button class="close-btn" onclick="hideAll()">× Close</button>

    <h3>Formate Specifier </h3>
    <p>%d or %i is used for int data type </p>
    <p>%f or %F is used for float data type </p>
    <p> %lf is used for diuble data type</p>
    <p> %c is used for char data types </p>
    <p> %s is used for string data types</p>

  </div>

  <div class="details" id="control">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Control Flow</h3>
    <p>In C programming, control flow statements are used to control the order in which instructions are executed in a
      program. These statements let the program make decisions, repeat tasks, and jump to specific parts of the code
      based on certain conditions.
    </p>
    <h3>Types of Control Flow Statements in C:
    </h3>
    <ul>
      <li>Decision-Making Statements
      </li>
      <li>Looping Statements
      </li>
      <li> Jump Statements
      </li>

    </ul>
  </div>
  <div class="details" id="control">
    <button class="close-btn" onclick="hideAll()">× Close</button>

    <h3>Decision-Making Statements</h3>

    <h3>if statement</h3>
    <p>The if statement allows the program to execute a block of code only if a specified condition evaluates to true.
      It is used to make decisions and control the flow based on conditions.
    </p>
    <pre>
      syntax:
              if (condition) {
                    // code to execute if condition is true
                }
    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250113160249557892/if_statement.webp"
      alt="if-flowchart">
    <h3>if-else statement</h3>
    <p>If the if condition is false, the else if condition is evaluated. If true, the corresponding code block is
      executed, and the remaining else if and else blocks are skipped</p>
    <pre>
      syntax:
                if (condition) {
                    // code if condition is true
                } else {
                    // code if condition is false
                  }

    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230220123250/flowchart_of_if_else_in_c.png"
      alt="if-else-flowchart">
    <h3>else-if-ladder</h3>
    <p>An else if ladder, also known as an if-else if-else statement, is a programming construct used to check multiple
      conditions sequentially. It allows a program to execute different blocks of code based on which condition is true,
      with a final else block to handle the case where none of the conditions are met.
    </p>
    <pre>
      syntax:
          if (condition1) {
                // code
          } else if (condition2) {
              // code
          } else {
              // default code
          }
</pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250102013047119893/if-else-if-ladder-flow-chart.webp"
      alt="else-if-flowchart">
    <h3>Nested if </h3>
    <p>A nested if statement is an if statement placed inside another if or else statement. This allows for more complex
      decision-making logic by evaluating multiple conditions in a hierarchical manner. Essentially, the inner if or
      else block is only executed if the outer if condition is true. </p>
    <pre>
      if(condition){
        if(condition){
          //if its true
        }else{
          //if its false 
        }
      }else if(condition){
        //statements
      }else{
        //statement
      }
    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240710162241/flowchart-of-nested-if-else-in-c.webp"
      alt="nested-if-flowchart">
    <h3>switch statement</h3>
    <p>
      The switch statement selects one block of code to execute from multiple options, based on the value of an
      expression. It is useful when you have many possible values to check.

    </p>
    <pre>
      switch (expression) {
    case value1:
        // code
        break;
    case value2:
        // code
        break;
    default:
        // code
}


    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250113161944104495/switch_statement.webp"
      alt="switch-flowchart">
    <h3>Example of Decision-Making Statements</h3>
    <pre>
#include <stdio.h>

int main() {
    int number, i;

    // if-else example
    printf("Enter an integer: ");
    scanf("%d", &number);

    if (number > 0)
        printf("The number is positive.\n");
    else if (number < 0)
        printf("The number is negative.\n");
    else
        printf("The number is zero.\n");

    // switch statement example
    printf("\nChoose a day (1-3): ");
    scanf("%d", &number);
    switch (number) {
        case 1:
            printf("Monday\n");
            break;
        case 2:
            printf("Tuesday\n");
            break;
        case 3:
            printf("Wednesday\n");
            break;
        default:
            printf("Invalid choice.\n");
    }

      </pre>
  </div>
  <div class="details" id="control">
    <button class="close-btn" onclick="hideAll()">× Close</button>

    <h3>Looping Statements</h3>
    <p>Looping statements allow you to execute a block of code repeatedly based on a condition. C provides several types
      of loops:</p>
    <ul>
      <li>for loop</li>
      <li>while loop</li>
      <li>do-while loop</li>
    </ul>
    <h3>for loop</h3>
    <p>The for loop repeats a block of code a specific number of times, based on an initialization, a condition, and an
      increment/decrement expression.
    </p>
    <pre>
      syntax:
      for (initialization; condition; increment/decrement) {
          // code to be executed
      }
    </pre>
    <pre>
    #include <stdio.h>
    int main()
    {

        int i;
        // for loop example
        for (i = 1; i <= 5; i++) {
            printf("Iteration %d\n", i);
        }
        return 0;
    }
    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230627104742/C-for-Loop.png" alt="for-flowchart ">

    <h3>while loop</h3>
    <p>The while loop repeatedly executes a block of code as long as the specified condition remains true. The condition
      is checked before each iteration.

    </p>
    <pre>
      syntax:
      while (condition) {
          // code to be executed
      }
    </pre>
    <pre>
      Example Program
      #include <stdio.h>
        int main() {
            int i = 1;
            // while loop example
            while (i <= 5) {
                printf("Iteration %d\n", i);
                i++;
            }
            return 0;
        }
      
    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220927171802/WhileloopinC2.png"
      alt="while-flowchart ">
    <h3>do-while loop</h3>
    <p>Executes the block at least once, then checks the condition.
    </p>
    <pre>
      syntax:
      do {
          // code to be executed
      } while (condition);
    </pre>
    <pre>
      Example Program
      #include <stdio.h>
        int main() {
            int i = 1;
            // do-while loop example
            do {
                printf("Iteration %d\n", i);
                i++;
            } while (i <= 5);
            return 0;
        }
      </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250321150401929348/dowhileloopinc.png"
      alt="do-while-flowchart">

  </div>
  <div class="details" id="control">
    <button class="close-btn" onclick="hideAll()">× Close</button>

    <h3>Jump Statements</h3>
    <p>Jump statements allow you to alter the flow of control in a program. C provides several jump statements:</p>
    <ul>
      <li>break</li>
      <li>continue</li>
      <li>goto</li>
      <li>return</li>
    </ul>
    <h3>break statement</h3>
    <p>The break statement is used to exit from a loop or switch statement prematurely.</p>
    <pre>
      Example Program
      #include <stdio.h>
        int main() {
            for (int i = 1; i <= 10; i++) {
                if (i == 5) {
                    break; // Exit the loop when i is 5
                }
                printf("%d ", i);
            }
            return 0;
        }
    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230307180351/flowchart-of-break-in-c.png"
      alt="flowchart-of-break-in-c">

    <h3>continue statement</h3>
    <p>The continue statement skips the current iteration of a loop and proceeds to the next iteration.</p>
    <pre>
      Example Program
      #include <stdio.h>
        int main() {
            for (int i = 1; i <= 10; i++) {
                if (i % 2 == 0) {
                    continue; // Skip even numbers
                }
                printf("%d ", i);
            }
            return 0;
        }
    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230606114014/continue-in-c.png"
      alt="flowchart-of-continue">
    <h3>goto statement</h3>
    <p>The goto statement allows you to jump to a specific label in the code. It is generally discouraged due to its
      potential to create unstructured code.</p>
    <pre>
      Example Program
      #include <stdio.h>
        int main() {
            int i = 1;
            start: // Label
            if (i <= 5) {
                printf("%d ", i);
                i++;
                goto start; // Jump back to the label
            }
            return 0;
        }
    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/goto.png" alt="flowchart-of-goto">

    <h3>return statement</h3>
    <p>The return statement is used to exit from a function and optionally return a value.</p>
    <pre>
      Example Program
      #include <stdio.h>
        int add(int a, int b) {
            return a + b; // Return the sum of a

  </div>


  <div class="details" id="functions">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Functions</h3>

    <p>A function definition informs the compiler about the function's name, its return type, and what it does. It is compulsory to define a function before it can be called..</p>
    <pre>
      return_type name () {
    // Body of function
          };
    </pre>
    <ul>
      <li>return_type: type of value the function return.</li>
      <li>name: name of the function.</li>
      <li>(): parentheses that may contain parameters.</li>
      <li>Body of function: code that defines what the function does.</li>


    </ul>
  </div>
  <div class="details" id="functions">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Function Definition</h3>
    <p>A function definition provides the actual body of the function, where the logic is implemented. It includes the
      return type, function name, parameters (if any), and the code block that defines what the function does.</p>
    <pre>
        Example Program
        #include <stdio.h>

        // Function definition
        void hello() {
            printf("Hello, World!\n");
        }

        int main() {
            hello(); // Function call
            return 0;
        }
      </pre>
    <h3>Output</h3>
    <pre>
        Hello, World!
      </pre>
  </div>
  <div class="details" id="functions">
    <button class="close-btn" onclick="hideAll()">× Close</button>

    <h3>Function Declaration</h3>
    <p>After defining a function, you can use it anywhere in the program by simply calling it with its name followed
      by
      parentheses ().</p>
    <p>A function declaration, also known as a function prototype, informs the compiler about the function's name,
      return type, and parameters (if any) without providing the actual body of the function. It is typically placed
      before the main function or in a header file.</p>
    <pre>
        Example Program
        #include <stdio.h>

        // Function declaration
        void hello();

        int main() {
            hello(); // Function call
            return 0;
        }

        // Function definition
        void hello() {
            printf("Hello, World!\n");
        }
      </pre>
    <h3>Output</h3>
    <pre>
        Hello, World!
      </pre>

  </div>



  <div class="details" id="functions">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Function Parameters</h3>
    <p>Functions can accept parameters, which are values passed to the function when it is called. Parameters allow
      functions to operate on different data without changing their code.</p>
    <pre>
        Example Program
        #include <stdio.h>

        // Function declaration with parameters
        void greet(char name[]);

        int main() {
            greet("Saarika"); // Function call with argument
            return 0;
        }

        // Function definition with parameters
        void greet(char name[]) {
            printf("Hello, %s!\n", name);
        }
      </pre>
    <h3>Output</h3>
    <pre>
        Hello, Saarika
      </pre>
  </div>
  <div class="details" id="functions">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Function Return Values</h3>
    <p>Functions can return values to the caller. The return type of the function specifies the type of value it will
      return. If a function does not return a value, its return type is void.</p>
    <pre>
        Example Program
        #include <stdio.h>

        // Function declaration with return type
        int add(int a, int b);

        int main() {
            int result = add(5, 3); // Function call with arguments
            printf("Sum: %d\n", result);
            return 0;
        }

        // Function definition with return type
        int add(int a, int b) {
            return a + b; // Return the sum
        }
      </pre>
    <h3>Output</h3>
    <pre>
        Sum: 8
      </pre>
  </div>


  <div class="details" id="functions">


    <p>For further Details visit <a href="https://www.geeksforgeeks.org/c/c-functions/"> geeksforgeeks</a></p>

  </div>

  <div class="details" id="arrays">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Arrays </h3>
    <p>An array is a collection of elements of the same data type, stored in contiguous memory locations. It allows
      you to store multiple values in a single variable, making it easier to manage and manipulate related data.</p>
    <p>Arrays are useful when you need to work with a fixed-size collection of elements, such as a list of numbers,
      characters, or any other data type. They provide a way to group related data together and access individual
      elements using an index.</p>
    <h3>Types of Array</h3>
    <ul>
      <li>Single-Dimensional Array</li>
      <li>Multi-Dimensional Array</li>
      <li>Dynamic Array</li>
    </ul>
  </div>
  <div class="details" id="arrays">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Single-Dimensional Array</h3>
    <p>A single-dimensional array is a linear collection of elements, where each element can be accessed using a single
      index. It is the simplest form of an array and is often used to store a list of related values.</p>
    <h3>Declaration of Single-Dimensional Array</h3>
    <pre>
      data_type array_name[size];
    </pre>
    <h3>Example of Single-Dimensional Array Declaration</h3>
    <pre>
      Example Program
      #include <stdio.h>

      int main() {
          int numbers[5]; // Declaration of an integer array with 5 elements
          return 0;
      }
    </pre>
    <h3>Initialization of Single-Dimensional Array</h3>
    <p>You can initialize a single-dimensional array at the time of declaration by providing values in curly braces.</p>
    <pre>
      data_type array_name[size] = {value1, value2, ...};
    </pre>
    <h3>Example of Single-Dimensional Array Initialization</h3>
    <pre>
      Example Program
      #include <stdio.h>

      int main() {
          int numbers[5] = {1, 2, 3, 4, 5}; // Initialization of an integer array with 5 elements
          return 0;
      }
    </pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250527113657849446/Arrays-in-C.webp"
      alt="arrays-in-c">
    <h3>Accessing Single-Dimensional Array Elements</h3>
    <p>You can access individual elements of a single-dimensional array using an index, which starts from 0.</p>
    <pre>
      array_name[index];
    </pre>
    <h3>Example of Accessing Single-Dimensional Array Elements</h3>
    <pre>
      Example Program
      #include <stdio.h>

      int main() {
          int numbers[5] = {1, 2, 3, 4, 5};
          printf("Element at index 0: %d\n", numbers[0]); // Accessing element at index 0
          return 0;
      }
    </pre>
  </div>
  <div class="details" id="arrays">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Two-Dimensional Array or Multi-Dimensional Array</h3>
    <p>A multi-dimensional array is an array of arrays, allowing you to create a grid-like structure. The most common
      type is a two-dimensional array, which can be visualized as a table with rows and columns.</p>
    <h3>Declaration of Multi-Dimensional Array</h3>
    <pre>
      data_type array_name[size1][size2];
    </pre>
    <h3>Example of Multi-Dimensional Array Declaration</h3>
    <pre>
      Example Program
      #include <stdio.h>

      int main() {
          int matrix[3][3]; // Declaration of a 3x3 integer matrix
          return 0;
      }
    </pre>
    <h3>Initialization of Multi-Dimensional Array</h3>
    <p>You can initialize a multi-dimensional array at the time of declaration by providing nested curly braces.</p>
    <pre>
      data_type array_name[size1][size2] = {{value11, value12, ...}, {value21, value22, ...}, ...};
    </pre>
    <h3>Example of Multi-Dimensional Array Initialization</h3>
    <pre>
      Example Program
      #include <stdio.h>

      int main() {
          int matrix[2][2] = {{1, 2}, {3, 4}}; // Initialization of a 2x2 integer matrix
          return 0;
      }
    </pre>
    <h3>Accessing Multi-Dimensional Array Elements</h3>
    <p>You can access individual elements of a multi-dimensional array using two indices: one for the row and one for
      the column.</p>
    <pre>
      array_name[row_index][column_index];
    </pre>
    <h3>Example of Accessing Multi-Dimensional Array Elements</h3>
    <pre>
      Example Program
      #include <stdio.h>

      int main() {
          int matrix[2][2] = {{1, 2}, {3, 4}};
          printf("Element at (0, 0): %d\n", matrix[0][0]); // Accessing element at row 0, column
          printf("Element at (1, 1): %d\n", matrix[1][1]); // Accessing element at row 1, column 1
          return 0;
      }
    </pre>
    <h3>Output</h3>
    <pre>
      Element at (0, 0): 1
      Element at (1, 1): 4
    </pre>


  </div>
  <div class="details" id="arrays">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Dynamic Array</h3>
    <p>A dynamic array is an array whose size can be determined at runtime. It allows you to create arrays with a size
      that is not known at compile time. Dynamic arrays are typically implemented using pointers and memory allocation
      functions.</p>
    <h3>Declaration of Dynamic Array</h3>
    <pre>
      data_type *array_name;
    </pre>
    <h3>Example of Dynamic Array Declaration</h3>
    <pre>
      Example Program
      #include <stdio.h>
      #include <stdlib.h>

      int main() {
          int *dynamicArray; // Declaration of a pointer for dynamic array
          return 0;
      }
    </pre>
    <h3>Memory Allocation for Dynamic Array</h3>
    <p>You can allocate memory for a dynamic array using the malloc() function from the stdlib.h library.</p>
    <pre>
      dynamicArray = (data_type *)malloc(size * sizeof(data_type));
    </pre>
    <h3>Example of Memory Allocation for Dynamic Array</h3>
    <pre>
      Example Program
      #include <stdio.h>
      #include <stdlib.h>

      int main() {
          int *dynamicArray;
          int size = 5;
          dynamicArray = (int *)malloc(size * sizeof(int)); // Allocating memory for a dynamic array of integers
          return 0;
      }
    </pre>
    <h3>Accessing Dynamic Array Elements</h3>
    <p>You can access individual elements of a dynamic array using an index, just like with regular arrays.</p>
    <pre>
      dynamicArray[index];
    </pre>
    <h3>Example of Accessing Dynamic Array Elements</h3>
    <pre>
      Example Program
      #include <stdio.h>
      #include <stdlib.h>

      int main() {
          int *dynamicArray;
          int size = 5;
          dynamicArray = (int *)malloc(size * sizeof(int)); // Allocating memory for a dynamic array of integers

          // Initializing the dynamic array
          for (int i = 0; i < size; i++) {
              dynamicArray[i] = i + 1; // Assigning values to the array
          }

          // Accessing and printing the elements of the dynamic array
          for (int i = 0; i < size; i++) {
              printf("Element at index %d: %d\n", i, dynamicArray[i]);
          }

          free(dynamicArray); // Freeing the allocated memory
          return 0;
      }
    </pre>
    <h3>Output</h3>
    <pre>
      Element at index 0: 1
      Element at index 1: 2
      Element at index 2: 3
      Element at index 3: 4
      Element at index 4: 5
    </pre>
    <p>In this example, we declared a dynamic array, allocated memory for it, initialized its elements, accessed and
      printed the elements, and finally freed the allocated memory using the free() function.</p>


  </div>
  <div class="details" id="arrays">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c-arrays/">GeeksforGeeks</a></li>
      <li><a href="https://www.programiz.com/c-programming/c-arrays">Programiz</a></li>
      <li><a href="https://www.javatpoint.com/c-arrays">JavaTpoint</a></li>
    </ul>

  </div>
  <div class="details" id="pointers">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Pointers</h3>
    <p>A pointer is a variable that stores the memory address of another variable. Instead of holding a direct value,
       it holds the address where the value is stored in memory. It is the backbone of low-level memory manipulation in C.
       Accessing the pointer directly will just give us the address that is stored in the pointer.For Example,</p>
    <pre>
      #include <stdio.h>

     int main() {
        int var = 10;
    
        // Store address of var variable
        int* ptr = &var;
    
        // Directly accessing ptr
        printf("%d", ptr);
    
      return 0;
   }
    </pre>
    <h3>output :</h3>
    <pre>0x7fffa0757dd4</pre>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20241210113214643291/pointer-in-c.png "
      alt="arrays-in-c">
    <p>Why Learn Pointer?
        <ul>
          <li>To access memory directly</li>
          <li>To pass large data(like arrays, structures) efficiently to function</li>
          <li>To return multiple values from a function</li>
          <li>For dynamic memory allocation.</li>
          <li>To build complex data structures like linked lists, trees, etc.</li>
        </ul>  
    </p>

  </div>
  <div class="details" id="pointers">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Decleration of pointer</h3>
    <p>A pointer is declared by specifying its name and type, just like simple variable declaration but with an asterisk (*) symbol added before the pointer's name.</p>
    <h3>Syntax:</h3>
    <pre>data_type* name</pre>
    <p>Here, data_type defines the type of data that the pointer is pointing to.
    An integer type pointer can only point to an integer. Similarly, a pointer of float type can point to a floating-point data, and so on.</p>
    <h3>Example:</h3>
    <pre>int *ptr;</pre>
    <p>In the above statement, pointer ptr can store the address of an integer. It is pronounced as pointer to integer.</p>
    <h3>Intialize the pointer</h3>
    <p>Pointer initialization means assigning some address to the pointer variable.
    In C, the (&) addressof operator is used to get the memory address of any variable. This memory address is then stored in a pointer variable.</p>
    <h3>Example:</h3>
    <pre>int var = 10; 

      // Initializing ptr
      int *ptr = &var;</pre>

    <h3>Size of pointers</h3>
    <p>The size of a pointer in C depends on the architecture (bit system) of the machine, not the data type it points to.</p>
    <li>On a 32-bit system, all pointers typically occupy 4 bytes.</li>
    <li>On a 64-bit system, all pointers typically occupy 8 bytes.</li>
    <p>The size remains constant regardless of the data type (int*, char*, float*, etc.). We can verify this using the sizeof operator.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

       int main() {
         int *ptr1;
         char *ptr2;
    
         // Finding size using sizeof()
         printf("%zu\n", sizeof(ptr1));
         printf("%zu", sizeof(ptr2));
    
       return 0;
      }
    </pre>
    <h3>Output:</h3>
    <pre>
      8
      8
    </pre>
    <p>The reason for the same size is that the pointers store the memory addresses, no matter what type they are. 
      As the space required to store the addresses of the different memory locations is the same,
       the memory required by one pointer type will be equal to the memory required by other pointer types.</p>

  </div>
  <div class="details" id="pointers">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Spacial Typs Of Pointerss</h3>
    <p>There are 4 special types of pointers that used or referred to in different contexts:</p>
    <h3>Null Pointer</h3>
    <p>The NULL Pointers are those pointers that do not point to any memory location.
    They can be created by assigning NULL value to the pointer. A pointer of any type can be assigned the NULL value.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

      int main() {
       // Null pointer
       int *ptr = NULL;
    
      return 0;
    }
    </pre>
    <p>NULL pointers are generally used to represent the absence of any address. 
    This allows us to check whether the pointer is pointing to any valid memory location by checking if it is equal to NULL.</p>
    <h3>Void Pointer</h3>
    <p>The void pointers in C are the pointers of type void.
    It means that they do not have any associated data type. 
    They are also called generic pointers as they can point to any type and can be typecasted to any type.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

      int main() {
        // Void pointer
        void *ptr;
    
      return 0;
    }
    </pre>
    <h3>Wild Pointer</h3>
    <p>The wild pointers are pointers that have not been initialized with something yet.
       These types of C-pointers can cause problems in our programs and can eventually cause them to crash.
       If values are updated using wild pointers, they could cause data abort or data corruption.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

      int main() {

        // Wild Pointer
        int *ptr;
    
      return 0;
    }
    </pre>
    <h3>Dangling Pointer</h3>
    <p>A pointer pointing to a memory location that has been deleted (or freed) is called a dangling pointer.
       Such a situation can lead to unexpected behavior in the program and also serve as a source of bugs in C programs.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>
      #include <stdlib.h>

      int main() {
        int* ptr = (int*)malloc(sizeof(int));

        // After below free call, ptr becomes a dangling pointer
        free(ptr);
        printf("Memory freed\n");

        // removing Dangling Pointer
        ptr = NULL;

      return 0;
    }
    </pre>
  </div>
  <div class="details" id="pointers">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/c-pointers/">GeeksforGeeks</a></li>
    </ul>

  </div>

  <div class="details" id="memorymanagement">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Memory Management</h3>
    <p>The memory layout of a program refers to how the program’s data is stored in the computer memory during its execution. Understanding this layout helps developers manage memory more efficiently and avoid issues such as segmentation faults and memory leaks.

    A C program's memory is organized into specific regions (segments) as shown in the below image, each serving distinct purposes for program execution.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250122155858092295/Memory-Layout-of-C-Program.webp" alt="memory layout image">
    <h3>Text Segment</h3>
    <p>The text segment (also known as code segment) is where the executable code of the program is stored. 
      It contains the compiled machine code of the program's functions and instructions.
       This segment is usually read-only and stored in the lower parts of the memory to prevent accidental modification of the code while the program is running.

    The size of the text segment is determined by the number of instructions and the complexity of the program.</p>
    <h3>Data Segment</h3>
    <p>The data segment stores global and static variables that are created by the programmer.
       It is present just above the code segment of the program. It can be further divided into two parts:</p>
    <h3>Heap Segment</h3>
    <p>Heap segment is where dynamic memory allocation usually takes place. 
      The heap area begins at the end of the BSS segment and grows towards the larger addresses from there. 
      It is managed by functions such as malloc(), realloc(), and free() which in turn may use the brk and sbrk system calls to adjust its size.

    The heap segment is shared by all shared libraries and dynamically loaded modules in a process.
     For example, the variable pointed by ptr will be stored in the heap segment:</p>
     <h3>Example:</h3>
     <pre>
      #include <stdio.h>

      int main() {
    
        // Create an integer pointer
        int *ptr = (int*) malloc(sizeof(int) * 10); 
      return 0;
     }
     </pre>
     <h3>Stack Segment</h3>
     <p>The stack is a region of memory used for local variables and function call management.
       Each time a function is called, a stack frame is created to store local variables, function parameters, and return addresses. 
       This stack frame is stored in this segment.

     The stack segment is generally located in the higher addresses of the memory and grows opposite to heap.
      They adjoin each other so when stack and heap pointer meet, free memory of the program is said to be exhausted.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

      void func() {
    
        // Stored in the stack
         int local_var = 10;  
      }

      int main() {
         func();
      return 0;
      }
    </pre>
    <h3>Example to Verify the Memory Layout</h3>
    <pre>
      #include <stdio.h>
      #include <stdlib.h>

      // Global variable
    int gvar = 66;

      // Constant global variable
      const int cgvar = 1010;

      // uninitialized global variable
    int ugvar;

      void foo() {
    
         // Local variable
         int lvar = 1;
         printf("Address of lvar:\t%p", (void*)&lvar);
      }

    int main() {
    
      // Heap variable
      int *hvar = (int*)malloc(sizeof(int));
    
    
      // Checking and comparing address of different
      // elements of program that should be stored in
      // different segements of the memory
      printf("Address of foo:\t\t%p\n", (void*)&foo);
      printf("Address of cgvar:\t%p\n", (void*)&cgvar);
      printf("Address of gvar:\t%p\n", (void*)&gvar);
      printf("Address of ugvar:\t%p\n", (void*)&ugvar);
      printf("Address of hvar:\t%p\n", (void*)hvar);
      foo();
    
	  return 0;
  }
    </pre>
    <h3>Output:</h3>
    <pre>
      Address of foo:         0x60d723996189
      Address of cgvar:       0x60d723997004
      Address of gvar:        0x60d723999010
      Address of ugvar:       0x60d723999018
      Address of hvar:        0x60d73b9072a0
      Address of lvar:        0x7ffd0e85e0c4
    </pre>

  </div>
  <div class="details" id="memorymanagement">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/memory-layout-of-c-program/">GeeksforGeeks</a></li>
    </ul>

  </div>
  <div class="details" id="structunienum">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Structures</h3>
    <p>In C, a structure is a user-defined data type that can be used to group items of possibly different types into a single type.
       The struct keyword is used to define a structure. 
      The items in the structure are called its member and they can be of any valid data type.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

        // Defining a structure
      struct A {
        int x;
      };

      int main() {
  
        // Creating a structure variable
        struct A a;
  	
  	     // Initializing member
  	     a.x = 11;

         printf("%d", a.x);
        return 0;
      }
    </pre>
    <h3>Output:</h3>
    <pre>11</pre>
    <h3>Explination</h3>
    <p> In this example, a structure A is defined to hold an integer member x.
       A variable a of type struct A is created and its member x is initialized to 11 by accessing it using dot operator.
       The value of a.x is then printed to the console.
       
       Structures are used when you want to store a collection of different data types, such as integers, floats, or even other structures under a single name.
        To understand how structures are foundational to building complex data structures,</p>
    <h3>Defining Structure</h3>
    <p>A structure is defined using the struct keyword followed by the structure name and its members.
       It is also called a structure template or structure prototype, and no memory is allocated to the structure in the declaration.</p>
    <pre>
      struct structure_name {
      data_type1 member1;
      data_type2 member2;
      ...
    };
    </pre>
    <li>structure_name: Name of the structure.</li>
    <li>member1, member2, ...: Name of the members.</li>
    <li>data_type1, data_type2, ...: Type of the members.</li>

    <h3>Creating Structure Variable</h3>
    <p>After structure definition, we have to create variable of that structure to use it. It is similar to the any other type of variable declaration:</p>
    <pre>struct strcuture_name var;</pre>
    <p>We can also declare structure variables with structure definition.</p>
    <pre>
      struct structure_name {
      ...
    }var1, var2....;
    </pre>
    <h3>Basic Operations of Structure</h3>
    <ol>
      <li> Access Structure Members</li>
      <li>Initialize Structure Members</li>
      <li> Copy Structure</li>
      <li>Passing Structure to Functions</li>
      <li>typedef for Structures</li>
    </ol>

    <h3>Uses Of stuctures</h3>
    <p>
      1.The structure can be used to define the custom data types that can be used to create some complex data types such as dates, time, complex numbers, etc.
       which are not present in the language.
      2.It can also be used in data organization where a large amount of data can be stored in different fields.
      3.Structures are used to create data structures such as trees, linked lists, etc.
      4.They can also be used for returning multiple values from a function.
    </p>

    
  </div>
  <div class="details" id="structunienum">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/structures-c/">GeeksforGeeks</a></li>
    </ul>

  </div>

  <div class="details" id="structunienum">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Union</h3>
    <p>In C, union is a user-defined data type that can contain elements of the different data types just like structure. 
      But unlike structures, all the members in the C union are stored in the same memory location.
       Due to this, only one member can store data at the given point in time.</p>
    <h3>Union Declaration</h3>
    <p>A union is declared similarly to a structure. Provide the name of the union and define its member variables:</p>
    <pre>
      union union_name{
      type1 member1;
      type2 member2;
      type3 member3;
      .       .
      .       .
    }
    </pre>
    <p>After declaration of a union then create a variable of union like below:</p>
    <pre>union_name variable_name;</pre>
    <p>We can also declare a variable at the declaration of union</p>
    <pre>
      union union_name{
      type1 member1;
      type2 member2;
      type3 member3;
      .       .
      .       .
    }variable_name;
    </pre>
    <h3>Initialization and Accessing</h3>
    <p>The value of a union variable can be accessed using the dot (.) operator.
       A value can be assigned to the union variable using the assignment operator (=).


    In a union, all the variables share the same memory, so only one variable can store a value at a time.
     If we try to access the value of another variable, the behavior will be undefined.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

      // Define a union with 
      // different data types
      union Student {
        int rollNo;
        float height;
        char firstLetter;
      };

      int main() {
    
       // Declare a union variable
        union Student data;

       // Assign and print the roll number
       data.rollNo = 21;
       printf("%d\n", data.rollNo);
       data.height = 5.2;
       printf("%.2f\n", data.height);
       data.firstLetter = 'N';
       printf("%c", data.firstLetter);

      return 0;
     }
    </pre>
    <h3>Output:</h3>
    <pre>
      21
      5.20
      N
    </pre>

  </div>
  <div class="details" id="structunienum">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/c-unions/">GeeksforGeeks</a></li>
    </ul>

  </div>

  <div class="details" id="structunienum">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>enums</h3>
    <p>In C, an enumeration (or enum) is a user defined data type that contains a set of named integer constants. 
      It is used to assign meaningful names to integer values, which makes a program easy to read and maintain.</p>
    <h3>Defining enum</h3>
    <p>An enum must be defined before we can use it in program.</p>
    <pre>
      enum enum_name { 
      n1, n2, n3, ... 
    };
    </pre>
    <p>where, n1, n2, n3, ... are names assigned to an integer value. By default, 
      first name n1 is assigned 0, n2 is assigned 1 and the subsequent ones are incremented by 1.</p>
    <h3>Example:</h3>
    <pre>
      enum calculate { 
      SUM, DIFFERENCE, PRODUCT, QUOTIENT
    };
    </pre>
    <h3>Create enum Variables</h3>
    <p>After enum is defined, we can create variables of that enum by using its specified name.</p>
    <pre>enum_name v;</pre>
    <h3>Initialization</h3>
    <p>An enum variable can be initialized either with a name defined in the enum definition or directly with its integer value.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

      // Defining enum
      enum direction {
        EAST, NORTH, WEST, SOUTH
      };

      int main() {

       // Creating enum variable
       enum direction dir = NORTH;
       printf("%d\n", dir);
    
       // This is valid too
       dir = 3;
       printf("%d", dir);
       return 0;
      } 
    </pre>
    <h3>Output:</h3>
    <pre>
      1
      3
    </pre>
    <h3>Applications Of enum</h3>
    <li>State Representation: Enums are commonly used to represent different states or modes in state machines, like in game development or process control systems.</li>
    <li>Error Codes: Enums are useful for defining a set of related error codes with meaningful names, making the code easier to debug and maintain.</li>
    <li>Menu Choices or User Inputs: Enums are useful for handling menu options or user input and can represent variety of user input such as days of the week.</li>
    <li>File Permissions: Enums are useful for handling file permissions in an operating system or file management system, with different permission levels such as READ, WRITE, and EXECUTE.</li>
  </div>
  <div class="details" id="structunienum">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/enumeration-enum-c/">GeeksforGeeks</a></li>
    </ul>

  </div>
  <div class="details" id="filehandling">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>File Handling</h3>
    <p>File handling in C is the process in which we create, open, read, write, and close operations on a file. 
      C language provides different functions such as fopen(), fwrite(), fread(), fseek(), fprintf(), etc.
       to perform input, output, and many different C file operations in our program.</p>
    <h3>Need of File Handling in C</h3>
    <p>So far, the operations in C program are done on a prompt/terminal in which the data is only stored in the temporary memory (RAM).
       This data is deleted when the program is closed. But in the software industry, most programs are written to store the information fetched from the program.
        The use of file handling is exactly what the situation calls for.

    File handling allows us to read and write data on files stored in the secondary memory such as hard disk from our C program.</p>
    <h3>C File Operations</h3>
    <p>C language provides the following different operations that we can perform on a file from our C program:</p>
    <li>Creating a new file.</li>
    <li>Opening an existing file.</li>
    <li>Reading from file.</li>
    <li>Writing to a file.</li>
    <li>Moving to a specific location in a file.</li>
    <li>Closing a file.</li>
  </div>
  <div class="details" id="filehandling">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>File</h3>
    <p>A file is a container of data. It can be classified into two types based on the way the file stores the data. They are as follows:</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230503150409/Types-of-Files-in-C.webp" alt="fileimg">
    <h3>Text files</h3>
    <p>A text file contains data in the form of ASCII characters and is generally used to store a stream of characters.</p>
    <li>Each line in a text file ends with a new line character ('\n').</li>
    <li>It can be read or written by any text editor.</li>
    <li>They are generally stored with .txt file extension.</li>
    <li>Text files can also be used to store the source code.</li>
    <h3>Binary Files</h3>
    <p>A binary file contains data in binary form (i.e. 0's and 1's) instead of ASCII characters.
       They contain data that is stored in a similar manner to how it is stored in the main memory.</p>
    <li>The binary files can be created only from within a program and their contents can only be read by a program.</li>
    <li>More secure as they are not easily readable.</li>
    <li>They are generally stored with .bin file extension.</li>
  </div>
  <div class="details" id="filehandling">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>File Operations</h3>
    <p>The file operations are performed by using the functions provided as the part of file handling API of C language.
       Following is the list of commonly used functions:</p>
       <img src="https://media.geeksforgeeks.org/wp-content/uploads/File-functions.jpg" alt="fileopeation">
       <h3>Types of Operation</h3>
      <li>Open a file</li>
      <li>Read a file</li>
      <li>Write a file</li>
      <li>Close a file</li>
      <li>Move pointer</li>
      <li>check foe end</li>
  </div>
  <div class="details" id="filehandling">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/basics-file-handling-c/">GeeksforGeeks</a></li>
    </ul>

  </div>
  <div class="details" id="dynamic">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Dynamic Memory Allocation</h3>
    <p>In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs).
       Also, once defined, we can neither change the size nor completely delete the memory.

    To resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. 
    Dynamic resources are stored in the heap memory instead of the stack.

    This feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.</p>
    <h3>Need of Dynamic Memory Allocation</h3>
    <p>As we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:

    The size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements.
    This creates another problem.This size of the array is much more than what is required to store the elements. This leads to the wastage of memory.
    
    This is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size.
     The size can be decided at runtime according to the requirement.
  </p>
  </div>
  <div class="details" id="dynamic">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Types Of Dynamic Memory Allocation</h3>
    <li>Malloc</li>
    <li>Calloc</li>
    <li>Free</li>
    <li>Realloc</li>

    <h3>*Malloc()</h3>
    <p>The malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. 
      The memory allocated by malloc() is uninitialized, meaning it contains garbage values.</p>
      <h3>Syntax:</h3>
      <pre>malloc(size);</pre>
      <p>where size is the number of bytes to allocate.

      This function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable.
      If allocation fails, it returns NULL pointer.</p>
      <h3>Example:</h3>
      <pre>
        #include <stdio.h>
        #include <stdlib.h>

        int main() {
        int *ptr = (int *)malloc(20);
    
         // Populate the array
        for (int i = 0; i < 5; i++)
           ptr[i] = i + 1;
        
           // Print the array
        for (int i = 0; i < 5; i++)
           printf("%d ", ptr[i]);
        return 0;
        }  
      </pre>
      <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250305233229499334/Malloc-function-in-c.webp" alt="malloc">
      <h3>*Calloc()</h3>
      <p>The calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. 
        It is used when you need memory with default zero values.</p>
      <h3>Syntax:</h3>
      <pre>calloc(n, size);</pre>
      <p>where n is the number of elements and size is the size of each element in bytes.

      This function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable.
      If allocation fails, it returns NULL pointer.</p>
      <h3>Example:</h3>
      <pre>
        #include <stdio.h>
        #include <stdlib.h>

        int main() {
         int *ptr = (int *)calloc(5, sizeof(int));
    
         // Checking if failed or pass
         if (ptr == NULL) {
            printf("Allocation Failed");
            exit(0);
          }
    
           // No need to populate as already
           // initialized to 0
        
           // Print the array
         for (int i = 0; i < 5; i++)
            printf("%d ", ptr[i]);
          return 0;
        }
      </pre>
      <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250305233554088828/calloc-function-in-c.webp" alt="calloc">
      <h3>*Free()</h3>
      <p>The memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system.
         It is essential to free memory that is no longer needed to avoid memory leaks.</p>
      <h3>Syntax:</h3>
      <pre>free(ptr);</pre>
      <p>where ptr is the pointer to the allocated memory.

      After freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.</p>
      <h3>Example:</h3>
      <pre>
        #include <stdio.h>
        #include <stdlib.h>

        int main() {
          int *ptr = (int *)calloc(sizeof(int), 5);
    
          // Do some operations.....
          for (int i = 0; i < 5; i++)
            printf("%d ", ptr[i]);
        
            // Free the memory after completing
            // operations
           free(ptr);
    
         return 0;
        }
      </pre>
      <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250305234252602298/Free-function-in-c.webp" alt="free">
      <h3>*Realloc()</h3>
      <p>realloc() function is used to resize a previously allocated memory block.
         It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.</p>
      <h3>Syntax:</h3>
      <pre>realloc(ptr, new_size);</pre>
      <p>where, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.

      This function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.</p>
      <h3>Example:</h3>
      <pre>
        #include <stdio.h>
        #include <stdlib.h>

        int main() {
          int *ptr = (int *)malloc(5 * sizeof(int));

          // Resize the memory block to hold 10 integers
          ptr = (int *)realloc(ptr, 10 * sizeof(int));
    
          // Check for allocation failure
          if (ptr == NULL) {
           printf("Memory Reallocation Failed");
           exit(0);
          }

          return 0;
        }
      </pre>
      <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250305235104974360/realloc-function-in-c.webp" alt="realloc">
  </div>
  <div class="details" id="dynamic">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/">GeeksforGeeks</a></li>
    </ul>

  </div>
  <div class="details" id="prepro">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Preproccessor</h3>
    <p>Preprocessors are programs that process the source code before the actual compilation begins.
       They are not part of the compilation process but operate separately, allowing programmers to modify the code before compilation. 
       It is the first step that the C source code goes through when being converted into an executable file.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230404112946/Compilation-Process-in-C.png" alt="preproces">

  </div>
  <div class="details" id="prepro">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Preprocessor Directives</h3>
    <p>The preprocessor directives are the instructions to the preprocessor for doing some tasks such as text substitutions, macro expansions, including header files,
       and many more before compiling the code. All of these preprocessor directives begin with a ‘#’ hash symbol.

      One of the most commonly used preprocessors is #include which is used to include the header files for different libraries in C programs.
      C provides more directives for different functionalities.</p>
    <h3>List of Preprocessor Directives</h3>
    <p>The following table lists all the preprocessor directives in C:</p>
    <ul>
      <li>Define: Used to define a macro</li>
      <li>undef: Used to undefine a macro </li>
      <li>include: Used to include a file in the source code program</li>
      <li>ifdef: Used to include a section of code if a certain macro is defined by #define</li>
      <li>ifndef: Used to include a section of code if a certain macro is not defined by #define</li>
      <li>if: Check for the specified condition</li>
      <li>else: Alternate code that executes when #if fails</li>
      <li>elif: Combines else and if for another condition check</li>
      <li>endif: Used to mark the end of #if, #ifdef, and #ifndef</li>
    </ul>
  </div>
   <div class="details" id="prepro">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Macros</h3>
    <p>Macros are used to define constants or create functions that are substituted by the preprocessor before the code is compiled.
       The two preprocessors #define and #undef are used to create and remove macros in C.</p>
    <pre>
      #define token value
      #undef token
    </pre>
    <p>where after preprocessing, the token will be expanded to its value in the program.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

      // Macro Definition
      #define LIMIT 5

      int main(){
        for (int i = 0; i < LIMIT; i++) {
          printf("%d \n", i);
        }
      return 0;
      }
    </pre>
    <h3>Output:</h3>
    <pre>
      0 
      1 
      2 
      3 
      4 
    </pre>
    <p>In the above program, before the compilation begins, the word LIMIT is replaced with 5.
       The word 'LIMIT' in the macro definition is called a macro template and '5' is macro expansion.</p>

  </div>
  <div class="details" id="prepro">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/cc-preprocessors/">GeeksforGeeks</a></li>
    </ul>
  </div>

  <div class="details" id="error">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Error Handling</h3>
    <p>In C programming, error handling is typically done using functions that handle runtime errors, 
      returning error codes or messages to notify the programmer about the failure or incorrect operation. 
      Since C does not provide built-in exception handling like other high-level languages (e.g., try-catch in Java or Python), error handling relies heavily on function return values, global variables, and system calls.

    A lot of C function calls return -1 or NULL or set an in case of an error code as the global variable errno,
     so quick tests on these values are easily done with an instance of ‘if statement’.</p>
    <h3>What is errno?</h3>
    <p>errno is a global variable defined in the <errno.h> header file that indicates the error that occurred during a function call in C. 
      When a function fails, the errno variable is automatically set to a specific error code, which helps identify the type of error encountered. 
      Different values of errno correspond to different types of errors, providing useful information for error handling in C programs.</p>
    <h3> different errno values</h3>
    <li>Operation not permitted</li>
    <li>No such file or directory</li>
    <li>No such process</li>
    <li>Interrupted system call</li>
    <li>I/O error</li>
    <li>No such device or address</li>
    <li>The argument list is too long</li>
    <li>Exec format error</li>
    <li>Bad file number</li>
    <li>No child processes</li>
    <li>Try again</li>
    <li>Out of memory</li>
    <li>Permission denied</li>
    <h3>Example:</h3>
    <pre>
      #include <errno.h> 
      #include <stdio.h> 

      int main()  { 
    
	      // If a file is opened which does not exist, 
	      // then it will be an error and corresponding 
	      // errno value will be set 
	      FILE* fp; 

	      // opening a file which does not exist 
	      fp = fopen("gfg.txt", "r"); 

	      printf("Value of errno: %d\n", errno); 

	     return 0; 
      }
    </pre>
    <h3>Output:</h3>
    <pre>Value of errno: 2</pre>
  </div>
  <div class="details" id="error">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Different Methods for Error Handling</h3>
    <p>Different methods are used to handle different kinds of errors in C. Some of the commonly used methods are:</p>
    <h3>1.Using if-else</h3>
    <p>In C, error handling is done manually since there is no built-in try-catch block like in other programming languages. To manage errors,
       we can use if-else statements to check for conditions and handle any potential errors that may occur during program execution.</p>
    <h3>Example:</h3>
    <pre>
      #include <errno.h> 
      #include <stdio.h> 

      int main()  { 
	      FILE* fp; 

	      // opening a file which does not exist 
	      fp = fopen("gfg.txt", "r");
	
	     if(fp == NULL){
	         printf("File openning error");
	      }else{
	         printf("File open successfully");
	      }
	      return 0; 
      }
    </pre>
    <h3>Output:</h3>
    <pre>File openning error</pre>
    <h3>2.perror()</h3>
    <p>The perror() function is used to print an error message to the standard error stream (stderr). 
      It helps to display the error string based on the global errno variable,
       which stores the error code set by system calls and library functions.</p>
    <h3>Example:</h3>
    <pre>
      #include <errno.h> 
      #include <stdio.h> 
      #include <string.h> 

      int main(){ 
       FILE* fp; 

       // Try opening a non-existent file, which sets errno
       fp = fopen("gfg.txt", "r"); 

       // Print the errno value after failed file opening
       printf("Value of errno: %d\n", errno); 
       perror("Message from perror");

      return 0; 
    }
    </pre>
    <h3>Output:</h3>
    <pre>
      Value of errno: 2
      Message from perror: No such file or directory
    </pre>
    <h3>3.strerror()</h3>
    <p>The strerror() function is also used to show the error description. This function returns a pointer to the textual representation of the current errno value.</p>
    <h3>Example:</h3>
    <pre>
      #include <errno.h>
      #include <stdio.h>
      #include <string.h>

      int main() {
        FILE* fp;

        // Try opening a non-existent file, setting errno
        fp = fopen("gfg.txt", "r");

        // Print errno value and corresponding error message
        printf("Value of errno: %d\n", errno);
        printf("The error message is : %s", strerror(errno));

      return 0;
    }
    </pre>
    <h3>Output:</h3>
    <pre>
      Value of errno: 2
      The error message is : No such file or directory
    </pre>
    <h3>3.ferror()</h3>
    <p>The ferror() function is used to check if an error occurred during a file operation. It returns a non-zero value if there was an error during the file operation.</p>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

      int main() {
        FILE *fptr = fopen("gfg.txt", "w");

       // Write data to the file
       fprintf(fptr, "Hello, GFG!");
    
  	   // Check error after writing data into file
       if(ferror(fptr)==0)
            printf("Data written successfully.");
       fclose(fptr);
      return 0;
    }
    </pre>
    <h3>Output:</h3>
    <pre>Data written successfully.</pre>
  </div>
  <div class="details" id="error">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>For further Details visit</h3>
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c/error-handling-in-c/">GeeksforGeeks</a></li>
    </ul>
  </div>
  <div class="details" id="error">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Debugging Techniques</h3>
    <p>Debugging is the process of finding and fixing errors (bugs) in your program.

    Bugs are mistakes that make your program crash, behave incorrectly, or give the wrong output.</p>
    <p>Before you start debugging, make sure your code is clean and organized:</p>
    <ul>
      <li>Use proper indentation to keep the structure clear.</li>
      <li>Give your variables clear, meaningful names that describe what they store.</li>
    </ul>
    <p>Clean code is easier to read - and easier to debug!

    In the sections below, we'll introduce several common debugging techniques.</p>
    <h3>1.Print debugging</h3>
    <p>Use printf() to print values at different points in your code to see what's going wrong:</p>
    <pre>
      int x = 10;
      int y = 0;
      printf("Before division\n"); // Debug output
      int z = x / y; // Crashes (division by zero)
      printf("After division\n"); // Never runsint x = 10;
      int y = 0;
      printf("Before division\n"); // Debug output
      int z = x / y; // Crashes (division by zero)
      printf("After division\n"); // Never runs
    </pre>
    <p>If you don't see "After division", the program crashed at x / y.</p>
    <h3>2.Check Variable Values</h3>
    <p>Print variables to see if they are what you expect:</p>
    <pre>
      int x = 10;
      int y = 5;
      int result = x - y;

      printf("Result: %d\n", result); // Result: 5
    </pre>
    <p>Expected 15? That means the logic is wrong: try using x + y instead.</p>
    <h3>3.Use a Debugger Tool</h3>
    <p>IDEs like Visual Studio, Code::Blocks, and VS Code have built-in debuggers that work with C. These tools let you:</p>
    <ul>
      <li>Pause your program using breakpoints</li>
      <li>Step through your code line by line</li>
      <li>Watch variables and see unexpected values as they change</li>
    </ul>
    
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Data Structures and Algorithmes</h3>
    <p>DSA (Data Structures and Algorithms) is the study of organizing data efficiently using data structures like arrays, stacks, and trees, paired with step-by-step procedures (or algorithms) to solve problems effectively. 
    Data structures manage how data is stored and accessed, while algorithms focus on processing this data.</p>
    <p>Why to Learn DSA?
      <li>Learning DSA boosts your problem-solving abilities and make you a stronger programmer.</li>
      <li>DSA is foundation for almost every software like GPS, Search Engines, AI ChatBots, Gaming Apps, Databases, Web Applications, etc</li>
      <li>Top Companies like Google, Microsoft, Amazon, Apple, Meta and many other heavily focus on DSA in interviews.</li>
    </p>
    <pre>Do you know the basics already and looking to prepare in limited time?  

    Try our free course GfG 160 where we have 160 most asked problems along with well written editorials and video explanations.
    The course also has 90 bonus problems.</pre>
    <h3>How to learn DSA?</h3>
    <ol>
      <li>Learn at-least one programming language (C, C++, Java, Python or JavaScript) and build your basic logic.</li>
      <li>Learn about Time and Space complexities</li>
      <li>Learn Data Structures (Arrays, Linked List, etc) and Algorithms (Searching, Sorting, etc).</li>
      <li>Once you learn main topics, it is important to solve coding problems against some predefined test cases,</li>
      <li>Solve problems daily using GfG Problem of the Day</li>
    </ol>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240917121350/5-Steps-to-learn-DSA-from-scratch.webp" alt="dsa">
    <p>Hoping you have learned a programming language of your choice, here comes the next stage of the roadmap - Learn about Time and Space Complexities.</p>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>Steps To Learn DSA</h3>
    <h3>1.Logic Building:</h3>
    <p>Once you have learned basics of a programming language, it is recommended that you learn basic logic building</p>
    <li>Logic Building Guide</li>
    <li>Quiz on Logic Building</li>
    <h3>2. Learn about Complexities:</h3>
    <p>To analyze algorithms, we mainly measure order of growth of time or space taken in terms of input size. We do this in the worst case scenario in most of the cases.
     Please refer the below links for a clear understanding of these concepts.</p>
     <li>Complexity Analysis Guide</li>
     <li>Quiz on Complexity Analysis</li>
    <h3>3.Array:</h3>
    <p>Array is a linear data structure where elements are allocated contiguous memory, allowing for constant-time access.</p>
    <li>Array Data Structure Guide</li>
    <li>Quiz on Arrays</li>
    <h3>4. Searching Algorithms:</h3>
    <p>Searching algorithms are used to locate specific data within a large set of data. It helps find a target value within the data.
       There are various types of searching algorithms, each with its own approach and efficiency.</p>
    <li>Searching Algorithms Guide</li>
    <li>Quiz on Searching</li>
    <h3>5.Sorting Algorithmes:</h3>
    <p>Sorting algorithms are used to arrange the elements of a list in a specific order, such as numerical or alphabetical. 
      It organizes the items in a systematic way, making it easier to search for and access specific elements.</p>
    <li>Sorting Algorithms Guide</li>
    <li>Quiz on Sorting</li>
    <h3>6.Hashing:</h3>
    <p>Hashing is a technique that generates a fixed-size output (hash value) from an input of variable size using mathematical formulas called hash functions.
       Hashing is commonly used in data structures for efficient searching, insertion and deletion.</p>
    <li>Hashing Guide</li>
    <li>Quiz on Hashing</li>
    <h3>7. Two Pointer Technique:</h3>
    <p>In Two Pointer Technique, we typically use two index variables from two corners of an array.
       We use the two pointer technique for searching a required point or value in an array.</p>
    <li>Two Pointer Technique</li>
    <li>Quiz on Two Pointer Technique</li>
    <h3>8. Window Sliding Technique:</h3>
    <p>In Window Sliding Technique, we use the result of previous subarray to quickly compute the result of current.</p>
    <li>Window Sliding Technique</li>
    <li>Quiz on Slidingw Windo</li>
    <h3>9.Prefix Sum Technique</h3>
    <p>In Prefix Sum Technique, we compute prefix sums of an array to quickly find results for a subarray.</p>
    <li>Prefix Sum Technique</li>
    <li>Quiz on Prefix Sum</li>
    <h3>10. String:</h3>
    <p>String is a sequence of characters, typically immutable and have limited set of elements (lower case or all English alphabets).</p>
    <li>Strings Guide</li>
    <li>Quiz on Strings</li>
    <h3>11. Recursion:</h3>
    <p>Recursion is a programming technique where a function calls itself within its own definition. I
      t is usually used to solve problems that can be broken down into smaller instances of the same problem.</p>
    <li>Recursive Algorithms Guide</li>
    <li>Quiz on Recursion</li>
    <h3>12.Matrix/Grid:</h3>
    <p>Matrix is a two-dimensional array of elements, arranged in rows and columns.
      It is represented as a rectangular grid, with each element at the intersection of a row and column.</p>
    <li>Matrix Guide</li>
    <li>Quiz on Matrix/Grid.</li>
    <h3>13.Linked List:</h3>
    <p>Linked list is a linear data structure that stores data in nodes, which are connected by pointers.
       Unlike arrays, nodes of linked lists are not stored in contiguous memory locations and can only be accessed sequentially, starting from the head of list.</p>
    <li>Linked List Guidet</li>
    <li>Quiz on Linked Lis</li>
    <h3>14.Stack:</h3>
    <p>Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. Stacks play an important role in managing function calls, memory, and are widely used in algorithms like stock span problem,
       next greater element and largest area in a histogram.</p>
    <li>Stack Guide</li>
    <li>Quiz on Stack</li>
    <h3>15. Queue:</h3>
    <p>Queue is a linear data structure that follows the First In, First Out (FIFO) principle.
       Queues play an important role in managing tasks or data in order, scheduling and message handling systems.</p>
    <li>Queue Guide</li>
    <li>Quiz on Queue</li>
    <h3>16. Deque:</h3>
    <p>A deque (double-ended queue) is a data structure that allows elements to be added or removed from both ends efficiently.</p>
    <h3>17.Tree:</h3>
    <p>Tree is a non-linear, hierarchical data structure consisting of nodes connected by edges, with a top node called the root and nodes having child nodes.
       It is widely used in file systems, databases, decision-making algorithms, etc.</p>
    <li>Tree Data Structure Guide</li>
    <li>Quiz on Tree</li>
    <h3>18.Heap</h3>
    <p>Heap is a complete binary tree data structure that satisfies the heap property. Heaps are usually used to implement priority queues,
       where the smallest or largest element is always at the root of the tree.</p>
    <li>Heap Guide</li>
    <li>Quiz on Heap</li>
    <h3>19. Graph:</h3>
    <p>Graph is a non-linear data structure consisting of a finite set of vertices(or nodes) and a set of edges(or links)that connect a pair of nodes.
       Graphs are widely used to represent relationships between entities.</p>
    <h3>20.Greedy Algorithm:</h3>
    <p>Greedy Algorithm builds up the solution one piece at a time and chooses the next piece which gives the most obvious and immediate benefit i.e., which is the most optimal choice at that moment.
       So the problems where choosing locally optimal also leads to the global solutions are best fit for Greedy.</p>
    <h3>21.Dynamic Programming:</h3>
    <p>Dynamic Programming is a method used to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations,
       leading to more efficient solutions for a wide range of problems.</p>
    <h3>22.Other Algorithmes:</h3>
    <p>Bitwise Algorithms: Operate on individual bits of numbers.</p>
    <p>Backtracking Algorithm : Follow Recursion with the option to revert and traces back if the solution from current point is not feasible.</p>
    <p>Divide and conquer: A strategy to solve problems by dividing them into smaller subproblems, solving those subproblems, and combining the solutions to obtain the final solution.</p>
    <p>Branch and Bound : Used in combinatorial optimization problems to systematically search for the best solution. It works by dividing the problem into smaller subproblems, or branches,
       and then eliminating certain branches based on bounds on the optimal solution.
       This process continues until the best solution is found or all branches have been explored.</p>
    <p>Geometric algorithms are a set of algorithms that solve problems related to shapes, points, lines and polygons.</p>
    <p>Randomized algorithms are algorithms that use randomness to solve problems. They make use of random input to achieve their goals, often leading to simpler and more efficient solutions.
       These algorithms may not product same result but are particularly useful in situations when a probabilistic approach is acceptable.</p>
    <h3>23.Advanced Data Structure and Algorithms</h3>
    <p>Advanced Data Structures like Trie, Segment Tree, Red-Black Tree and Binary Indexed Tree offer significant performance improvements for specific problem domains.
       They provide efficient solutions for tasks like fast prefix searches, range queries, dynamic updates, and maintaining balanced data structures, which are crucial for handling large datasets and real-time processing.</p>
    <li>trie</li>
    <li>Segment Tree</li>
    <li>Red-Black Tree</li>
    <li>Binary Indexed Tree</li>
    <li>Practice Advanced Data Structures</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>1.Logic Building Problems</h3>
    <p>Logic building is about creating clear, step-by-step methods to solve problems using simple rules and principles.
       It’s the heart of coding, enabling programmers to think, reason, and arrive at smart solutions just like we do.</p>
    <p>Here are some tips for improving your programming logic:</p>
    <ol>
      <li>Understand the problem: Read and understand the problem statement.</li>
      <li>Generate Examples: Create additional input and output cases for each problem.</li>
      <li>Draw observations: Draw observations and patterns based on the examples you created.</li>
      <li>Start with Basic: First, think of the basic way to solve the problem then optimize the solution.</li>
    </ol>
    <h3>Basic Problems</h3>
    <p>
    <li>Check Even or Odd</li>
    <li>Multiplication Table</li>
    <li>Sum of Naturals</li>
    <li> Sum of Squares of Naturals</li>
    <li> Swap Two Numbers</li>
    <li> Closest Number</li>
    <li>Dice Problem</li>
    <li>Nth Term of AP</li>
    </p>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>2.Analysis of Algorithms</h3>
    <p>Analysis of Algorithms is a fundamental aspect of computer science that involves evaluating performance of algorithms and programs.
     Efficiency is measured in terms of time and space.</p>
    <h3>Basics on Analysis of Algorithms:</h3>
    <p>
      <li>Why is Analysis Important?</li>
      <li>Order of Growth</li>
      <li>Asymptotic Analysis</li>
      <li>Worst, Average and Best Cases of Algorithms</li>
    </p>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>3.Array Data Structure Guide</h3>
    <p>In this article, we introduce array, implementation in different popular languages, its basic operations and commonly seen problems / interview questions.</p>
    <li>An array stores items (in case of C/C++ and Java Primitive Arrays) or their references (in case of Python, JS, Java Non-Primitive) at contiguous locations.</li>
    <li>It offers mainly the following advantages over other data structures.
        Random Access : i-th item can be accessed in O(1) Time as we have the base address and every item or reference is of same size.
        Cache Friendliness : Since items / references are stored at contiguous locations, we get the advantage of locality of reference.</li>
    <li>It is not useful in places where we have operations like insert in the middle, delete from middle and search in a unsorted data.</li>
    <li>It is a fundamental and linear data structure using which we build other data structures like Stack Queue, Deque, Graph, Hash Table, etc.</li>
    <p>Basic problems</p>
   <li> Print Alternates</li>
   <li>Linear Search</li>
   <li>Largest Element</li>
   <li>Second Largest</li>
   <li>Largest Three</li>
   <li>Leaders in an array</li>
   <li>Check if Sorted</li>
   <li>Remove Duplicates from Sorted</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>4.Searching Algorithms</h3>
    <p>Searching algorithms are essential tools in computer science used to locate specific items within a collection of data. In this tutorial, we are mainly going to focus upon searching in an array. When we search an item in an array,
       there are two most common algorithms used based on the type of input array.</p>
    <li>Linear Search : It is used for an unsorted array. It mainly does one by one comparison of the item to be search with array elements. It takes linear or O(n) Time.</li>
    <li>Binary Search : It is used for a sorted array. It mainly compares the array's middle element first and if the middle element is same as input, then it returns. Otherwise it searches in either left half or right half based on comparison result (Whether the mid element is smaller or greater).
       This algorithm is faster than linear search and takes O(Log n) time.</li>
    <p>Problems</p>
    <li>Largest in an Array</li>
    <li>Second Largest in an array</li>
    <li>Largest three in an array</li>
    <li>Missing Number</li>
    <li>First Repeating</li>
    <li>Missing and Repeating</li>
    <li>Count 1’s in a sorted binary array</li>
    <li>Closest to 0 Sum Pair</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>5.Sorting Algorithms</h3>
    <p>A Sorting Algorithm is used to rearrange a given array or list of elements in an order. For example, a given array [10, 20, 5, 2] becomes [2, 5, 10, 20] after sorting in increasing order and becomes [20, 10, 5, 2] after sorting in decreasing order.</p>
    <li>There exist different sorting algorithms for different different types of inputs, for example a binary array, a character array, an array with a large range of values or an array with many duplicates or a small vs large array.</li>
    <li>The algorithms may also differ according to output requirements. For example, stable sorting (or maintains original order of equal elements) or not stable.</li>
    <li>Sorting is provided in library implementation of most of the programming languages. These sorting functions typically are general purpose functions with flexibility of providing the expected sorting order (increasing or decreasing or by a specific key in case of objects).</li>
    <p>Problems</p>
     <li>Check if an array is Sorted</li>
     <li>Sort an array of two types</li>
     <li>Sort a String</li>
     <li>Sort Each Row of a Matrix</li>
     <li>Sort a Matrix</li>
     <li>Sort a Linked List</li>
     <li>Sort in Wave Form</li>
     <li>Sort by Frequency</li>
     <li>Sort from Different Machines</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>6.Hashing in Data Structure</h3>
    <p>Hashing is a technique used in data structures that efficiently stores and retrieves data in a way that allows for quick access.</p>
    <li>Hashing involves mapping data to a specific index in a hash table (an array of items) using a hash function. It enables fast retrieval of information based on its key.</li>
    <li>The great thing about hashing is, we can achieve all three operations (search, insert and delete) in O(1) time on average.</li>
    <li>Hashing is mainly used to implement a set of distinct items (only keys) and dictionaries (key value pairs).</li>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240807120551/Introduction-to-Hashing.webp" alt="hashing">
    <p>Problems</p>
    <li>Check tor Subset</li>
    <li>Check for Disjoint</li>
    <li>Check for Equal</li>
    <li>Fizz Buzz</li>
    <li>Max distance between two occurrences</li>
    <li>Duplicate within K Distance</li>
    <li>Intersection of Two Arrays</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>7.Two Pointers Technique</h3>
    <p>Two pointers is really an easy and effective technique that is typically used for Two Sum in Sorted Arrays, Closest Two Sum, Three Sum, Four Sum, Trapping Rain Water and many other popular interview questions. Given a sorted array arr (sorted in ascending order) and a target,
       find if there exists any pair of elements (arr[i], arr[j]) such that their sum is equal to the target.</p>
    <h3>Illustration : </h3>
    <pre>
       Input: arr[] = {10, 20, 35, 50}, target =70
       Output:  Yes
       Explanation : There is a pair (20, 50) with given target.

       Input: arr[] = {10, 20, 30}, target =70
       Output :  No
       Explanation : There is no pair with sum 70

       Input: arr[] = {-8, 1, 4, 6, 10, 45], target = 16
       Output: Yes
       Explanation : There is a pair (6, 10) with given target.
    </pre>
    <h3>Naive Method - O(n^2) Time and O(1) Space</h3>
    <p>The very basic approach is to generate all the possible pairs and check if any of them add up to the target value. To generate all pairs, we simply run two nested loops.</p>
    <pre>
      #include <stdbool.h>
#include <stdio.h>

// Function to check whether any pair exists
// whose sum is equal to the given target value
bool twoSum(int arr[], int n, int target){

    // Iterate through each element in the array
    for (int i = 0; i < n; i++){

        // For each element arr[i], check every
        // other element arr[j] that comes after it
        for (int j = i + 1; j < n; j++){

            // Check if the sum of the current pair
            // equals the target
            if (arr[i] + arr[j] == target)
                return true;
        }
    }
    // If no pair is found after checking
    // all possibilities
    return false;
}

int main(){

    int arr[] = {0, -1, 2, -3, 1};
    int target = -2;
    int n = sizeof(arr) / sizeof(arr[0]);

    // Call the twoSum function and print the result
    if (twoSum(arr, n, target))
        printf("true\n");
    else
        printf("false\n");
  
    return 0;
}
    </pre>
    <h3>output:</h3>
    <pre>true</pre>
    <h3>Better Approaches - Binary Search and Hashing</h3>
    <p>We can use more methods like Binary Search and Hashing to solve this problem
     (Please refer Two Sum article for details) in better time complexity but Two Pointer Technique is the best solution for this problem that works well for sorted arrays.</p>
    <h3>Two-Pointer Technique - O(n) time and O(1) space</h3>
    <p>The idea of this technique is to begin with two corners of the given array. We use two index variables left and right to traverse from both corners.</p>
    <h3>Illustration:</h3>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240930115143/two-pointer-tech--2.webp" alt="twopointimg">
    <pre>
      #include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

// Comparison function for qsort
int compare(const void *a, const void *b){
    return (*(int *)a - *(int *)b);
}

// Function to check whether any pair exists
// whose sum is equal to the given target value
bool twoSum(int arr[], int n, int target){
    // Sort the array
    qsort(arr, n, sizeof(int), compare);

    int left = 0, right = n - 1;

    // Iterate while left pointer is less than right
    while (left < right){
        int sum = arr[left] + arr[right];

        // Check if the sum matches the target
        if (sum == target)
            return true;
        else if (sum < target)
            left++; // Move left pointer to the right
        else
            right--; // Move right pointer to the left
    }
    // If no pair is found
    return false;
}

int main(){
    int arr[] = {0, -1, 2, -3, 1};
    int target = -2;
    int n = sizeof(arr) / sizeof(arr[0]);

    // Call the twoSum function and print the result
    if (twoSum(arr, n, target))
        printf("true\n"); 
    else
        printf("false\n");

    return 0;
}
    </pre>
    <h3>Output:</h3>
    <pre>true</pre>
    <p>
      How does this work?
      We need to prove that we never miss a valid pair.

      Case 1 ( When we increment left ) In this case we simply ignore current arr[left] and move to the next element by doing left++.
      We do this when arr[left] + arr[right] is smaller than the target. The reason this step is safe is, if arr[left] is giving a smaller value than sum, then it will given even much less values for the elements before arr[right].
      Now how about the elements after arr[right]? Note that we moved right when we were sure that no pair can be formed with the current right (arr[right] was too high), so arr[left] can not form a pair with those values also.
    </p>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>8.Sliding Window Technique</h3>
    <p>Sliding Window Technique is a method used to solve problems that involve subarray or substring or window.</p>
    <li>The main idea is to use the results of previous window to do computations for the next window.</li>
    <li>This technique is commonly used in algorithms like finding subarrays with a specific sum, finding the longest substring with unique characters,
       or solving problems that require a fixed-size window to process elements efficiently.</li>
    <h3>Example Problem - Maximum Sum of a Subarray with K Elements</h3>
    <p>Given an array and an integer k, we need to calculate the maximum sum of a subarray having size exactly k.</p>
    <pre>
      Input  : arr[] = {100, 200, 300, 400}, k = 2
Output : 700
We get maximum sum by considering the subarray [300, 400]

Input  : arr[] = {1, 4, 2, 10, 23, 3, 1, 0, 20}, k = 4 
Output : 39
We get maximum sum by adding subarray {4, 2, 10, 23} of size 4.

Input  : arr[] = {2, 3}, k = 3
Output : Invalid
There is no subarray of size 3 as size of whole array is 2.
    </pre>
    <h3>Naive Approach - O(n k) Time and O(1) Space</h3>
    <p>We run two nest loops and compute sums of all subarrays of size k</p>
    <pre>
      // O(n*k) solution for finding maximum sum of
// a subarray of size k
#include <limits.h>
#include <math.h>
#include <stdio.h>

// Find maximum between two numbers.
int max(int num1, int num2)
{
    return (num1 > num2) ? num1 : num2;
}

// Returns maximum sum in a subarray of size k.
int maxSum(int arr[], int n, int k)
{
    // Initialize result
    int max_sum = INT_MIN;

    // Consider all blocks starting with i.
    for (int i = 0; i < n - k + 1; i++) {
        int current_sum = 0;
        for (int j = 0; j < k; j++)
            current_sum = current_sum + arr[i + j];

        // Update result if required.
        max_sum = max(current_sum, max_sum);
    }

    return max_sum;
}

// Driver code
int main()
{
    int arr[] = { 1, 4, 2, 10, 2, 3, 1, 0, 20 };
    int k = 4;
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("%d", maxSum(arr, n, k));
    return 0;
}

// This code is contributed by Aditya Kumar (adityakumar129)
    </pre>
    <h3>Output:</h3>
    <pre>24</pre>
    <h3>Using the Sliding Window Technique - O(n) Time and O(1) Space</h3>
    <li>We compute the sum of the first k elements out of n terms using a linear loop and store the sum in variable window_sum.</li>
    <li>Then we will traverse linearly over the array till it reaches the end and simultaneously keep track of the maximum sum.</li>
    <li>To get the current sum of a block of k elements just subtract the first element from the previous block and add the last element of the current block.</li>
    <h3>The below representation will make it clear how the window slides over the array.</h3>
    <pre>
      <p>Consider an array arr[] = {5, 2, -1, 0, 3} and value of k = 3 and n = 5

      This is the initial phase where we have calculated the initial window sum starting from index 0 .
       At this stage the window sum is 6. Now, we set the maximum_sum as current_window</p>
      <img src="https://media.geeksforgeeks.org/wp-content/uploads/sliding-window1.png">
      <p>Now, we slide our window by a unit index. Therefore, now it discards 5 from the window and adds 0 to the window. Hence, we will get our new window sum by subtracting 5 and then adding 0 to it. So, our window sum now becomes 1.
         Now, we will compare this window sum with the maximum_sum. As it is smaller, we won't change the maximum_sum. </p>
      <img src="https://media.geeksforgeeks.org/wp-content/uploads/sliding-window2.png" >
      <p>Similarly, now once again we slide our window by a unit index and obtain the new window sum to be 2. Again we check if this current window sum is greater than the maximum_sum till now. Once, again it is smaller so we don't change the maximum_sum.
      Therefore, for the above array our maximum_sum is 6.</p>
      <img src="https://media.geeksforgeeks.org/wp-content/uploads/sliding-window3.png">
    </pre>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>9.Prefix Sum Array - Implementation and Applications</h3>
    <p>Given an array arr[] of size n, the task is to find the prefix sum of the array. A prefix sum array is another array prefixSum[] of the same size, such that prefixSum[i] is arr[0] + arr[1] + arr[2] . . . arr[i].</p>
    <h3>Examples:</h3>
    <pre>
      Input: arr[] = [10, 20, 10, 5, 15]
Output: 10 30 40 45 60
Explanation: For each index i, add all the elements from 0 to i:
prefixSum[0] = 10, 
prefixSum[1] = 10 + 20 = 30, 
prefixSum[2] = 10 + 20 + 10 = 40 and so on.

Input: arr[] = [30, 10, 10, 5, 50]
Output: 30 40 50 55 105
Explanation: For each index i, add all the elements from 0 to i:
prefixSum[0] = 30, 
prefixSum[1] = 30 + 10 = 40,
prefixSum[2] = 30 + 10+ 10 = 50 and so on.
    </pre>
    <h3>Prefix Sum Implementation</h3>
    <pre>
      The idea is to create an array prefixSum[] of size n, and for each index i in range 1 to n - 1, set prefixSum[i] = prefixSum[i - 1] + arr[i].
    </pre>
    <h3>To solve the problem follow the given steps:</h3>
    <li>Declare a new array prefixSum[] of the same size as the input array</li>
    <li>Run a for loop to traverse the input array</li>
    <li>For each index add the value of the current element and the previous value of the prefix sum array</li>
    <h3>Below is the implementation of the above approach:</h3>
    <pre>
      #include <bits/stdc++.h>
using namespace std;

// function to find the prefix sum array
vector<int> findPrefixSum(vector<int> &arr) {
    int n = arr.size();
    
    // to store the prefix sum
    vector<int> prefixSum(n);

    // initialize the first element
    prefixSum[0] = arr[0];

    // Adding present element with previous element
    for (int i = 1; i < n; i++)
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    
    return prefixSum;
}

int main() {
    vector<int> arr = {10, 20, 10, 5, 15};
    vector<int> prefixSum = findPrefixSum(arr);
    for(auto i:prefixSum) {
        cout<<"i"<<"";
    }
    return 0;
}
    </pre>
    <h3>Output:</h3>
    <pre>10 30 40 45 60 </pre>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>10.String in Data Structure</h3>
    <p>A string is a sequence of characters. The following facts make string an interesting data structure.</p>
    <li>Small set of elements. Unlike normal array, strings typically have smaller set of items. For example, lowercase English alphabet has only 26 characters. ASCII has only 256 characters.</li>
    <li>Strings are immutable in programming languages like Java, Python, JavaScript and C#.</li>
    <li>Many String Problems can optimized using the fact that the character set size is small. For example sorting can be done faster, counting frequencies of items is faster and many interesting interview questions are based on this.</li>
    <p>Problems</p>
    <li>Check for Binary</li>
    <li>Camel Case Conversion</li>
    <li>Binary Substrings with Corners as 1s</li>
    <li>Check for Panagram</li>
    <li>Check for Palindrome</li>
    <li>Check for Substring</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>11.Recursive Algorithms</h3>
    <p>Recursion is technique used in computer science to solve big problems by breaking them into smaller,
       similar problems. The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Using a recursive algorithm, certain problems can be solved quite easily.</p>
    <li>A recursive algorithm takes one step toward solution and then recursively call itself to further move. The algorithm stops once we reach the solution.</li>
    <li>Since called function may further call itself, this process might continue forever. So it is essential to provide a base case to terminate this recursion process.</li>
    <h3>Steps to Implement Recursion</h3>
    <pre>
      Step1 - Define a base case: Identify the simplest (or base) case for which the solution is known or trivial. This is the stopping condition for the recursion, as it prevents the function from infinitely calling itself.

Step2 - Define a recursive case: Define the problem in terms of smaller subproblems. Break the problem down into smaller versions of itself, and call the function recursively to solve each subproblem.

Step3 - Ensure the recursion terminates: Make sure that the recursive function eventually reaches the base case, and does not enter an infinite loop.

Step4 - Combine the solutions: Combine the solutions of the subproblems to solve the original problem.
    </pre>
    <h3>Example:</h3>
    <pre>
      #include <stdio.h>

int fact(int n) {
  
    // BASE CONDITION
    if (n == 0)
        return 1;
  
    return n * fact(n - 1);
}

int main() {
    printf("Factorial of 5 : %d\n", fact(5));
    return 0;
}
    </pre>
    <h3>Output:</h3>
    <pre>Factorial of 5 : 120</pre>
    <h3>Illustration of the above code:</h3>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240924132748/factorial.webp" >
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>12.Matrix Data Structure</h3>
    <p>Matrix Data Structure is a two-dimensional array arranged in rows and columns. It is commonly used to represent mathematical matrices and is fundamental in various fields like mathematics, computer graphics,
       and data processing. Matrices allow for efficient storage and manipulation of data in a structured format.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240416133310/Introduction-to-Matrix.webp" >
    <h3>Representation of Matrix Data Structure:</h3>
    <p>As you can see from the below image, the elements are organized in rows and columns. As shown in the image, the cell a[0][0] is the first element of the first row and first column.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240415190237/Representation-of-Matrix-1024.webp" >
    <h3>Declaration of Matrix Data Structure :</h3>
    <p>Declaration of a Matrix or two-dimensional array is very much similar to that of a one-dimensional array, given as follows.</p>
    <pre>
      #include <stdio.h>

int main() {

    // Defining number of rows and columns in matrix
    int rows = 3, cols = 3;
  
    // Array Declaration
    int arr[rows][cols];
  
    return 0;
}
    </pre>
    <h3>Initializing Matrix Data Structure:</h3>
    <p>In initialization, we assign some initial value to all the cells of the matrix. Below is the implementation to initialize a matrix in different languages:</p>
    <pre>
      #include <stdio.h>

int main() {

    // Initializing a 2-D array with values
    int arr[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    return 0;
}
    </pre>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>13.Linked List Data Structure</h3>
    <p>A linked list is a fundamental data structure in computer science. It mainly allows efficient insertion and deletion operations compared to arrays. Like arrays,
       it is also used to implement other data structures like stack, queue and deque. Here’s the comparison of Linked List vs Arrays</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250619155958124670/Linked-list.webp" >
    <h3>Linked List:</h3>
    <li>Data Structure: Non-contiguous</li>
    <li>Memory Allocation: Typically allocated one by one to individual elements</li>
    <li>Insertion/Deletion: Efficient</li>
    <li>Access: Sequential</li>

    <h3>Singly Linked List Tutorial</h3>
    <p>A singly linked list is a fundamental data structure, it consists of nodes where each node contains a data field and a reference to the next node in the linked list.
       The next of the last node is null, indicating the end of the list. Linked Lists support efficient insertion and deletion operations.</p>
    <h3>Understanding Node Structure</h3>
    <p>In a singly linked list, each node consists of two parts: data and a pointer to the next node. This structure allows nodes to be dynamically linked together, forming a chain-like sequence.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240917161540/Singly-Linked-List.webp" >
    <pre>
      // Definition of a Node in a singly linked list
struct Node {
    int data;          
    struct Node* next;
};

// Function to create a new Node
struct Node* newNode(int data) {
    struct Node* temp = 
      (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}
    </pre>
    <h3>Doubly Linked List Tutorial</h3>
    <p>A doubly linked list is a more complex data structure than a singly linked list, but it offers several advantages. The main advantage of a doubly linked list is that it allows for efficient traversal of the list in both directions.
       This is because each node in the list contains a pointer to the previous node and a pointer to the next node. This allows for quick and easy insertion and deletion of nodes from the list, as well as efficient traversal of the list in both directions.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240809123741/Insertion-at-the-End-in-Doubly-Linked-List-copy.webp" >
    <h3>Representation of Doubly Linked List in Data Structure</h3>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240809124907/Node-Structure-of-Doubly-Linked-List.webp" >
    <pre>
      struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;
};

// Function to create a new node
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)
    malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}
    </pre>
    <h3>Introduction to Circular Linked List</h3>
    <p>A circular linked list is a data structure where the last node connects back to the first, forming a loop. This structure allows for continuous traversal without any interruptions. Circular linked lists are especially helpful for tasks like scheduling and managing playlists, allowing for smooth navigation. In this tutorial,
       we’ll cover the basics of circular linked lists, how to work with them, their advantages and disadvantages, and their applications.</p>
    <h3>What is a Circular Linked List?</h3>
    <p>A circular linked list is a special type of linked list where all the nodes are connected to form a circle. Unlike a regular linked list, which ends with a node pointing to NULL, the last node in a circular linked list points back to the first node. This means that you can keep traversing the list without ever reaching a NULL value.</p>
    <pre>
      // Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value){

    // Allocate memory
    struct Node *newNode = 
      (struct Node *)malloc(sizeof(struct Node));

    // Set the data
    newNode->data = value;
  
    // Initialize next to NULL
    newNode->next = NULL;
  
    // Return the new node
    return newNode;
}
    </pre>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>14.Stack Data Structure</h3>
    <p>A Stack is a linear data structure that follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out). LIFO implies that the element that is inserted last, 
      comes out first and FILO implies that the element that is inserted first, comes out last.</p>
    <p>It behaves like a stack of plates, where the last plate added is the first one to be removed. Think of it this way:
      <li>Pushing an element onto the stack is like adding a new plate on top.</li>
      <li>Popping an element removes the top plate from the stack.</li>
    </p>
    <img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726165552/Stack-Data-Structure.png">
    <p>Problems</p>
    <li>The Celebrity Problem</li>
    <li>Implement Queue using Stacks</li>
    <li>Implement two stacks in an array</li>
    <li>Implement Stack using Queues</li>
    <li>Stack using priority queue or heap</li>
    <li>Stack using single queue</li>
    <li>Infix to Postfix</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>15.Queue Data Structure</h3>
    <p>A Queue Data Structure is a fundamental concept in computer science used for storing and managing data in a specific order.</p>
    <li>It follows the principle of "First in, First out" (FIFO), where the first element added to the queue is the first one to be removed.</li>
    <li>It is used as a buffer in computer systems where we have speed mismatch between two devices that communicate with each other. For example, CPU and keyboard and two devices in a network</li>
    <li>Queue is also used in Operating System algorithms like CPU Scheduling and Memory Management, and many standard algorithms like Breadth First Search of Graph, Level Order Traversal of a Tree.</li>
    <img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726165642/Queue-Data-structure1.png" >
    <p>Problems</p>
    <li>Implement Stack using Queues</li>
    <li>Minimum Depth of a Binary Tree</li>
    <li>BFS for a Graph</li>
    <li>Detect cycle in an undirected graph using BFS</li>
    <li>Right View of a Binary Tree</li>
    <li>Check whether a graph is Bipartite</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>16.Tree Data Structure</h3>
    <p>Tree Data Structure is a non-linear data structure in which a collection of elements known as nodes are connected to each other via edges such that there exists exactly one path between any two nodes.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240415185343/tree-data-structure-banners-(2).webp" >
    <h3>Introduction to Tree Data Structure</h3>
    <p>Tree data structure is a hierarchical structure that is used to represent and organize data in the form of parent child relationship. The following are some real world situations which are naturally a tree.</p>
    <li>Folder structure in an operating system</li>
    <li>Tag structure in an HTML (root tag the as html tag) or XML document.</li>
    <p>The topmost node of the tree is called the root, and the nodes below it are called the child nodes. Each node can have multiple child nodes, and these child nodes can also have their own child nodes, forming a recursive structure.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240424125622/Introduction-to-tree-.webp" >
    <h3>Basic Terminologies In Tree Data Structure:</h3>
    <li>Parent Node: The node which is an immediate predecessor of a node is called the parent node of that node. {B} is the parent node of {D, E}.</li>
    <li>Child Node: The node which is the immediate successor of a node is called the child node of that node. Examples: {D, E} are the child nodes of {B}.</li>
    <li>Root Node: The topmost node of a tree or the node which does not have any parent node is called the root node. {A} is the root node of the tree. A non-empty tree must contain exactly one root node and exactly one path from the root to all other nodes of the tree.</li>
    <li>Leaf Node or External Node: The nodes which do not have any child nodes are called leaf nodes. {I, J, K, F, G, H} are the leaf nodes of the tree.</li>
    <li>Ancestor of a Node: Any predecessor nodes on the path of the root to that node are called Ancestors of that node. {A,B} are the ancestor nodes of the node {E}</li>
    <li>Descendant: A node x is a descendant of another node y if and only if y is an ancestor of x.</li>
    <li>Sibling: Children of the same parent node are called siblings. {D,E} are called siblings.</li>
    <li>Level of a node: The count of edges on the path from the root node to that node. The root node has level 0.</li>
    <li>Internal node: A node with at least one child is called Internal Node.</li>
    <li>Neighbour of a Node: Parent or child nodes of that node are called neighbors of that node.</li>
    <li>Subtree: Any node of the tree along with its descendant.</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>17.Heap Data Structure</h3>
    <p>A Heap is a complete binary tree data structure that satisfies the heap property: for every node, the value of its children is greater than or equal to its own value.
       Heaps are usually used to implement priority queues, where the smallest (or largest) element is always at the root of the tree.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20241105101737867907/min-heap-1.webp" >
    <p>Problems</p>
    <li>Check if an array is Heap?</li>
    <li>K’th Smallest & K'th Largest</li>
    <li>Heap Sort</li>
    <li>Heap Sort for Decreasing Order</li>
    <li>Height of a Heap with N Nodes</li>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>18.Graph Algorithms</h3>
    <p>Graph is a non-linear data structure like tree data structure. The limitation of tree is, it can only represent hierarchical data. For situations where nodes or vertices are randomly connected with each other other, 
      we use Graph. Example situations where we use graph data structure are, a social network, a computer network, a network of locations used in GPS and many more examples where different nodes or vertices are connected without any hierarchic or constraint on structure.</p>
    <h3>Representations of Graph</h3>
    <p>Here are the two most common ways to represent a graph : For simplicity, we are going to consider only unweighted graphs in this post.</p>
    <h3>Adjacency Matrix Representation</h3>
    <p>An adjacency matrix is a way of representing a graph as a matrix of boolean (0's and 1's)

    Let's assume there are n vertices in the graph So, create a 2D matrix adjMat[n][n] having dimension n x n.</p>
    <pre>
      <li>If there is an edge from vertex i to j, mark adjMat[i][j] as 1. </li>
      <li>If there is no edge from vertex i to j, mark adjMat[i][j] as 0.</li>
    </pre>
    <h3>Representation of Undirected Graph as Adjacency Matrix:</h3>
    <p>The below figure shows an undirected graph. Initially, the entire Matrix is ​​initialized to 0. If there is an edge from source to destination, 
      we insert 1 to both cases (adjMat[source][destination] and adjMat[destination][source]) because we can go either way.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20230727130331/Undirected_to_Adjacency_matrix.png" >
    <pre>
      #include<stdio.h>

#define V 4

void addEdge(int mat[V][V], int i, int j) {
    mat[i][j] = 1;
    mat[j][i] = 1; // Since the graph is undirected
}

void displayMatrix(int mat[V][V]) {
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++)
            printf("%d ", mat[i][j]);
        printf("\n");
    }
}

int main() {
    // Create a graph with 4 vertices and no edges
    // Note that all values are initialized as 0
    int mat[V][V] = {0};

    // Now add edges one by one
    addEdge(mat, 0, 1);
    addEdge(mat, 0, 2);
    addEdge(mat, 1, 2);
    addEdge(mat, 2, 3);

    /* Alternatively, we can also create using the below
       code if we know all edges in advance

    int mat[V][V] = {
        {0, 1, 0, 0},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {0, 0, 1, 0}
    }; */

    printf("Adjacency Matrix Representation\n");
    displayMatrix(mat);

    return 0;
}
    </pre>
    <h3>Output:</h3>
    <pre>
      Adjacency Matrix Representation
0 1 1 0 
1 0 1 0 
1 1 0 1 
0 0 1 0 
    </pre>

  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>19.Greedy Algorithms</h3>
    <p>Greedy algorithms are a class of algorithms that make locally optimal choices at each step with the hope of finding a global optimum solution.</p>
    <li>At every step of the algorithm, we make a choice that looks the best at the moment. To make the choice, we sometimes sort the array so that we can always get the next optimal choice quickly. We sometimes also use a priority queue to get the next optimal item.</li>
    <li>After making a choice, we check for constraints (if there are any) and keep picking until we find the solution.</li>
    <li>Greedy algorithms do not always give the best solution. For example, in coin change and 0/1 knapsack problems, we get the best solution using Dynamic Programming.</li>
    <li>Examples of popular algorithms where Greedy gives the best solution are Fractional Knapsack, Dijkstra's algorithm, Kruskal's algorithm, Huffman coding and Prim's Algorithm</li>
    <h3>Example:</h3>
    <pre>
      // C Program to find the minimum number of coins
// to construct a given amount using greedy approach

#include <stdio.h>
#include <stdlib.h>

int compare(const void *a, const void *b) {
    return (*(int *)b - *(int *)a);
}

int minCoins(int coins[], int n, int amount) {
  
    // Sort the coins in descending order
    qsort(coins, n, sizeof(int), compare);
  
    int res = 0;
  
    // Start from the coin with highest denomination
    for(int i = 0; i < n; i++) {
        if(amount >= coins[i]) {
          
            // Find the maximum number of ith coin 
            // we can use
            int cnt = (amount / coins[i]);
          
            // Add the count to result
            res += cnt;
          
            // Subtract the corresponding amount from
            // the total amount
            amount -= (cnt * coins[i]);
        }
      
        // Break if there is no amount left
        if(amount == 0)
            break;
    }
    return res;
}

int main() {
    int coins[] = {5, 2, 10, 1};
    int n = sizeof(coins) / sizeof(coins[0]);
    int amount = 39;
  
    printf("%d", minCoins(coins, n, amount));
    return 0;
}
    </pre>
    <h3>Output:</h3>
    <pre>6</pre>
  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>20.Dynamic Programming or DP</h3>
    <p>Dynamic Programming is an algorithmic technique with the following properties.</p>
    <li>It is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming.</li>
    <li>The idea is to simply store the results of subproblems so that we do not have to re-compute them when needed later. This simple optimization typically reduces time complexities from exponential to polynomial.</li>
    <li>Some popular problems solved using Dynamic Programming are Fibonacci Numbers, Diff Utility (Longest Common Subsequence), Bellman–Ford Shortest Path, Floyd Warshall, Edit Distance and Matrix Chain Multiplication.</li>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250106170245473186/Dynamic-Programming-or-DP-1.webp" >

  </div>
  <div class="details" id="dsa">
    <button class="close-btn" onclick="hideAll()">× Close</button>
    <h3>21.Other Algorithmes</h3>
    <h3>Bitwise Algorithms</h3>
    <p>Bitwise algorithms in Data Structures and Algorithms (DSA) involve manipulating individual bits of binary representations of numbers to perform operations efficiently.
       These algorithms utilize bitwise operators like AND, OR, XOR, NOT, Left Shift, and Right Shift.</p>
    <h3>Backtracking Algorithm</h3>
    <p>Backtracking algorithms are like problem-solving strategies that help explore different options to find the best solution. They work by trying out different paths and if one doesn't work, they backtrack and try another until they find the right one.
       It's like solving a puzzle by testing different pieces until they fit together perfectly.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20231016112106/backtracking-banner-(1).png" >
    <h3>Divide and Conquer Algorithm</h3>
    <p>Divide and Conquer algorithm is a problem-solving strategy that involves.</p>
    <li>Divide : Break the given problem into smaller non-overlapping problems.</li>
    <li>Conquer : Solve Smaller Problems</li>
    <li>Combine : Use the Solutions of Smaller Problems to find the overall result.</li>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240403162200/Divide-and-Conquer-banner.webp" >
    <h3>Branch and Bound Algorithm</h3>
    <p>The Branch and Bound Algorithm is a method used in combinatorial optimization problems to systematically search for the best solution.
       It works by dividing the problem into smaller subproblems, or branches, and then eliminating certain branches based on bounds on the optimal solution.
     This process continues until the best solution is found or all branches have been explored. Branch and Bound is commonly used in problems like the traveling salesman and job scheduling.</p>
    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20221031102458/IntroductiontoBranchandBound.png" >
    <p>Branch and bound is an algorithmic technique used in computer science to solve optimization problems. Branch and bound is a systematic way of exploring all possible solutions to a problem by dividing the problem space into smaller sub-problems and then applying bounds or constraints to eliminate certain subproblems from consideration.</p>
    <h3>Geometric Algorithms</h3>
    <p>Geometric algorithms are a type of algorithm that deal with solving problems related to geometry. These algorithms are used to solve various geometric problems such as computing the area of a polygon,
       finding the intersection of geometric shapes, determining the convex hull of a set of points, and many other tasks related to geometric objects and their properties. Geometric algorithms are important in various fields such as computer graphics, computer-aided design, robotics, and geographical information systems.</p>
    <h3>Randomized Algorithms</h3>
    <p>Randomized algorithms in data structures and algorithms (DSA) are algorithms that use randomness in their computations to achieve a desired outcome. These algorithms introduce randomness to improve efficiency or simplify the algorithm design. By incorporating random choices into their processes, randomized algorithms can often provide faster solutions or better approximations compared to deterministic algorithms. 
      They are particularly useful in situations where exact solutions are difficult to find or when a probabilistic approach is acceptable.</p>
    <p>For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). We use randomization in Quick Sort to avoid a pattern for which it always causes a worst case. This is useful when we implement a library sort function using Quick Sort as it allows the library function to be a general purpose function and work almost uniformly for all cases.</p>
    
  </div>
  <script src="script.js"></script>
</body>

</html>